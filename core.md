1. ~~[Что такое JRE, JDK, JVM?](#1-Что-такое-jdk-jre-jvm)~~ 
1. **[Типы данных.](#2-Типы-данных)**
1. **[Преобразование типов.](#3-Преобразование-типов)**
1. ~~[Классы-обертки.](#4-Классы-обертки)~~
1. **[Autoboxing и unboxing.](#5-autoboxing-и-unboxing)**
1. ~~[Массивы.](#6-Массивы)~~
1. ~~[Инкремент и декремент.](#7-Инкремент-и-декремент)~~
1. [Модификаторы доступа.](#8-Модификаторы-доступа)
1. [Основные принципы ООП.](#9-Основные-принципы-ООП)
1. [Абстрактные классы и интерфейсы.](#10-Абстрактные-классы-и-интерфейсы)
1. [Вложенные классы.](#11-Вложенные-классы)
1. [Конструкторы.](#12-Конструкторы)
1. [Ключевое слово super.](#13-Ключевое-слово-super)
1. [Статические члены класса.](#14-Статические-члены-класса)
1. [Порядок конструирования объекта.](#15-Порядок-конструирования-объекта)
1. [Статическое и динамическое связывание.](#16-Статическое-и-диманическое-связывание)
1. [Класс Object.](#17-Класс-object)
1. **[Методы hashCode() и equals().](#18-Методы-hashcode-и-equals)**
1. ~~[Отличия equals() от ==.](#19-Отличия-equals-от-)~~
1. **[Строки.](#20-Строки)**
1. **[Integer Pool.](#21-integer-pool)**
1. [Неизменяемые классы.](#22-Неизменяемые-классы)
1. [Переопределение методов.](#23-Переопределение-методов)
1. [Перегрузка методов и конструкторов.](#24-Перегрузка-методов-и-конструкторов)
1. ~~[Передача параметров.](#25-Передача-параметров)~~
1. ~~[Разница между final, finally и finalize?](#26-Разница-между-final-finally-и-finalize)~~
1. ~~[Пакеты.](#27-Пакеты)~~
1. **[Исключения.](#28-Исключения)**
1. [Generics.](#29-generics)
1. **[Интерфейсы Comparator и Comparable.](#30-Интерфейсы-comparator-и-comparable)**
1. ~~[Интерфейс Cloneable.](#31-Интерфейс-cloneable)~~
1. [Сериализация.](#32-Сериализация)
1. [Перечисления.](#33-Перечисления)
1. ~~[Рефлексия.](#34-Рефлексия)~~
1. **[Загрузка классов.](#35-Загрузка-классов)**
1. ~~[Типы ссылок.](#36-Типы-ссылок)~~
1. **[Основы управления памятью.](#37-Как-работает-garbage-collector)**
1. **[Как работает Garbage Collector.](#38-Основы-управления-памятью-в-java)**
1. ~~[Ключевое слово native.](#39-Ключевое-слово-native)~~
1. ~~Singleton.~~

## 1. Что такое JDK, JRE, JVM?

**Java Development Kit** (сокр. JDK) — бесплатно распространяемый компанией
Oracle Corporation (ранее Sun Microsystems) комплект разработчика приложений на языке Java, включающий в себя
компилятор Java (javac), стандартные библиотеки классов Java, примеры, документацию, различные утилиты и исполнительную систему Java (JRE).

*JDK кратко - для программирования*.

**Java Runtime Environment** (сокр. JRE) — минимальная реализация виртуальной машины,
необходимая для исполнения Java-приложений, без компилятора и других средств разработки.
Состоит из виртуальной машины — Java Virtual Machine и библиотеки Java-классов.

*JRE кратко - для работы*.

**Java Virtual Machine** (сокращенно Java VM, JVM) — виртуальная машина Java — основная часть исполняющей системы Java,
так называемой Java Runtime Environment (JRE). Виртуальная машина Java интерпретирует Байт-код Java, предварительно
созданный из исходного текста Java-программы компилятором Java (javac). JVM может также использоваться для выполнения программ,
написанных на других языках программирования.

## 2. Типы данных.

Существует два типа данных:

1. Примитивные типы данных
1. Ссылочные типы данных

**Примитивные типы данных**

Существует 8 примитивных типов данных:

- byte (целые числа, 1 байт, диапазон от -128 до 127, по умолчанию - 0)
- short (целые числа, 2 байта, диапазон от -32768 до 32767, по умолчанию - 0)
- int (целые числа, 4 байта, диапазон от -2147483648 до 2147483647, по умолчанию - 0)
- long (целые числа, 8 байтов, по умолчанию - 0L)
- float (с плавающей точкой, 4 байта, по умолчанию - 0.0f)
- double (с плавающей точкой, 8 байтов, по умолчанию - 0.0d)
- char (символ Unicode, 2 байта, по умолчанию - '\u0000')
- boolean (значение true/false, 1 байт, по умолчанию - *false*)

**Ссылочные типы данных**

В ссылочные типы входят все классы, интерфейсы, массивы. Ссылочные переменные хранят лишь ссылки на объекты,
причем различные переменные могут ссылаться на один и тот же объект.
Выражение ссылочного типа имеет значение либо *null*,
либо ссылку, указывающую на некоторый объект в виртуальной памяти Java машины.

## 3. Преобразование типов.

Преобразование типа *Т1* в тип *T2* позволяет выражению типа *T1* трактоваться в период компиляции как выражение типа *T2*.
В одних случаях это чисто синтаксическая конструкция, не влияющая на генерируемый код, в других преобразование типа
требует дополнительных действий в период выполнения по изменению значения выражения или дополнительных проверок
правильности применяемого преобразования.

Например, без проблем можно присвоить значение типа `int` переменной типа `long`, т.к. все числа из диапазона типа
`int` гарантировано помещаются в диапазон чисел `long`. В этом случае Java выполнит преобразование автоматически.
А что если присвоить переменной типа `byte` значение типа `double`? Java не сможет автоматически выполнить преобразование.

Не все числа типа `double` могут стать числом типа `byte`. Но часть чисел может, например, число 9.
В таком случае используется *приведение типов*, чтобы подсказать Java о допустимости операции.

*Существуют следующие виды преобразований:*

- **Расширяющие преобразования чисел**

*Расширяющие преобразования чисел* — это преобразования числового типа в "больший" числовой тип, которые считаются безопасными,
т.к. не приводит к потере величины преобразуемого значения.

Такими преобразованиями являются:

- преобразования *byte* в *short*, *int*, *long*, *float* и *double*;
- преобразования *short* в *int*, *long*, *float* и *double*;
- преобразования *char* в *int*, *long*, *float* и *double*;
- преобразования *int* в *long*, *float* и *double*;
- преобразования *long* в *float* и *double*;
- преобразования *float* в *double*.

- **Сужающие преобразования чисел**

Сужающие преобразования чисел — это преобразования числового типа в "меньший" числовой тип, которые могут привести как
к потере величины, так и к потере точности. Такими преобразованиями в Java являются:

- преобразования *byte* в *char*;
- преобразования *short* в *byte* и *char*;
- преобразования *int* в *byte*, *short* и *char*;
- преобразования *long* в *byte*, *short*, *int* и *char*;
- преобразования *float* в *byte*, *short*, *int*, *long* и *char*;
- преобразования *double* в *byte*, *short*, *int*, *long*, *float* и *char*;

*Пример:*

```java
int a;
byte b;

// какие-то операции с переменной
b = (byte) a;
```

Как видно, в скобках указывается тип, к которому нужно явно привести переменную.

Существует ещё вариант *приведения с усечением*. Это когда число с плавающей точкой приводится к целочисленному типу.
В этом случае отбрасывается дробная часть. Например, число 3.94 будет усечено до числа 3, несмотря на то, что число
4 было ближе к 3.94.

```java
double a = 3.94;
byte b = (byte) a;
```

*Если размер целочисленной части слишком велик для целочисленного типа, то значение будет уменьшено до результата деления
по модулю на диапазон целевого типа.*

```java
int x = 300;
byte b = (byte) x;
System.out.println(b); // 300 % 256 результат - 44
```

**Преобразования при операциях**

Допустим у нас есть выражение, где промежуточное значение может выходить за пределы допустимого диапазона.

```java
byte a = 44;
byte b = 55;
byte c = 101;
int d = a * b - c;
```

При умножении переменных a * b промежуточный результат вышел за пределы диапазона допустимых значений для типов `byte`.
Java во время вычисления промежуточных результатов автоматически повышает тип каждого операнда до `int` и ошибки не происходит.

Так же существуют следующие правила:

- Типы всех значений `byte`, `short`, `char` повышаются до типа `int`, как это было рассмотрено выше.
- Если один операнд имеет тип `long`, то тип всего выражения повышается до `long`.
- Если один операнд имеет тип `float`, то тип всего выражения повышается до `float`.
- Если один операнд имеет тип `double`, то тип всего выражения повышается до `double`.

## 4. Классы-обертки

в Java используются базовые типы (примитивы), такие как *int* или *double*, для хранения элементарных
данных типов. Для хранения таких данных из-за более высокой производительности применяются базовые типы,
а не объекты. В этом случае использование объектов добавляет неприемлемые издержки даже к простейшей вычислительной операции.
Таким образом, базовые типы не являются частью иерархии объектов и не наследуют класс *Object*.

Несмотря на выигрыш в производительности, предлагаемый базовыми типами, возникают ситуации, требующие
объектного представления. Кроме того, много стандартных структур данных оперирует объектами, и, следовательно нельзя
использовать эти структуры для хранения данных базовых типов.

Java предоставляет классы, которые инкапсулируют примитивные данные в объекты.

Для каждого примитивного типа существует свой класс-обертка:

**Byte, Short, Long, Float, Double, Char, Boolean и Integer.**

Каждый класс имеет простой конструктор, который принимает на вход значение базового типа:

```java
    Integer i = new Integer(100);
    Character c = new Character('c');
    Boolean b = new Boolean(true);
```

Классы обертки используются в *коллекциях*. Нельзя создать коллекцию примитивных типов,
поэтому для обхода этого ограничения ввели классы-обертки.

```java
Map<int, double> map; // wrong
Map<Integer, Double> map; // right
```

## 5. Autoboxing и unboxing.

**Автоупаковка и автораспаковка** связаны с оболочками типов *(type wrapper)* и со способом вставки
значений в экземпляры таких оболочек и извлечения значений из них. Автоупаковка и автораспаковка появились в Java с версии 1.5.
Они представляют собой удобный способ для автоматического преобразования примитивных типов данных в классы-обертки и наоборот.

Значение притивного типа инкапсулируется в оболочку в момент конструирования объекта.
Упакованное таким образом значение можно получить обратно с помощью вызова одного из методов,
определенных в оболочке.

*Например, в каждом классе-обертке есть следующие методы:*

```java
byte byteValue();
double doubleValue();
float floatValue();
int intValue();
long longValue();
short shortValue();
```

**Автоупаковка** - это автоматическое преобразование примитивного типа данных в объект соответствующего класса-оболочки.
*К примеру, int в Integer, long в Long, double в Double и т.д.*

Компилятор Java применяет автоупаковку в следующих случаях:

- Примитив передан в параметр метода, который ожидает объект соответствующего класса-оболочки.

    *Например, в метод с параметром Integer можно передавать int – компилятор Java будет преобразовывать int в Integer.*

    ```java
    class AutoboxingExample1 {

        public static void myMethod(Integer num){
            System.out.println(num); // 2
        }

        public static void main(String[] args) {

           /* passed int (primitive type), it would be
            * converted to Integer object at Runtime
            */
         myMethod(2);

        }

    }
    ```

- Присваивание переменной значение соответствующего класса-оболочки.

    *Например, переменная типа Long может принимать long.*

    ```java
    Long lnum = 32L; // присваивание long для Long - выполняется автоупаковка
    Integer inum = 3; // присваивание int для Integer - выполняется автоупаковка
    ```

- При работе с коллекциями.

    ```java
    ArrayList<Integer> arrayList = new ArrayList<Integer>();
    arrayList.add(11); // выполняется автоупаковка - int примитив преобразуется в Integer
    arrayList.add(22); // выполняется автоупаковка
    ```

**Распаковка** - это присваивание объекта класса-оболочки переменной примитивного типа.

*Например, переменная типа long может принимать Long.*

Компилятор Java применяет распаковку в следующих случаях:

- Объект класса-оболочки передан в параметр метода, который ожидает значение соответствующего примитивного типа.

    ```java
    class UnboxingExample1 {

       public static void myMethod(int num){
    	System.out.println(num); // 100
       }

       public static void main(String[] args) {

        	Integer inum = new Integer(100);

            /* passed Integer wrapper class object, it
             * would be converted to int primitive type
             * at Runtime
             */
        	myMethod(inum);
        }

    }
    ```

- Присваивание переменной примитивного типа соответствующего объекта класса-оболочки.

    ```java
    Integer inum = new Integer(5);
    int num = inum; // выполняется распаковка - Integer преобразуется в int
    ```

- При работе с коллекциями.

    ```java
    ArrayList arrayList = new ArrayList()
    int num = arrayList.get(0); // выполняется распаковка т.к get() возвращает Integer
    ```

**Что делает компилятор при автоупаковке и распаковке**

*Автоупаковка:*
`Integer number = 100;`

*Компилятор выполняет следующее (или что было в java до 1.5):*
`Integer number = Integer.valueOf(100);`

*Распаковка:*
```java
Integer num2 = new Integer(50);
int inum = num2;
```

*Компилятор выполняет следующее (или что было в java до 1.5):*
```java
Integer num2 = new Integer(50);
int inum = num2.intValue();
```

Точно так же *автоупаковка и распаковка* работает с другими класса-обертками и примитивами.

*Примечание: не следует сравнивать между собой примитивы и объекты. Объекты сравниваются с объектами
(`equals()`, `compareTo()`), примитивы с примитивами(`==`, `<`, `>`)*

## 6. Массивы.

Массив — это конечная последовательность упорядоченных элементов одного типа, доступ к каждому элементу в которой осуществляется по индексу.
*Размер массива задаётся при создании массива и не может быть изменён в дальнейшем.* Индекс начального элемента — 0.
Индекс последнего элемента в массиве — на единицу меньше, чем размер массива. В Java массивы являются объектами.
Имя переменной массива указывает на адрес какого-то фрагмента данных в памяти. Кроме адреса в этой переменной ничего не хранится.

*Варианты объявления массива*

- `type[] name;`
- `type name[];`

*Варианты инициализации массива*

- `type[] name = new type[size];`
- `type name[] = {i, j, k, d};`
- `type name[] = new type[]{i, j, k, d};`

Если массив был создан с помощью оператора *new*, то каждый его элемент получает значение по умолчанию.
Каким оно будет определяется на основании типа данных (0 для `int`, 0.0 для `double`, *false* для `boolean`, *null* для ссылочных типов данных и т. д.).

Если программа выйдет за пределы индекса массива, то программа остановится с ошибкой времени исполнения *ArrayOutOfBoundsException*.

Массивы в Java однородные, т.е. все элементы в массиве должны быть одного типа, за исключением случаев, разрешённых полиморфизмом.
Если тип массива не примитивный, а определённый через класс, то реальный массив, помимо объектов заданного класса,
может содержать также объекты подклассов того класса, который был указан в объявлении массива.

## 7. Инкремент и декремент.

В Java существует два оператора, называемых операторами **инкремента и декремента** (++ и --).
Эти операторы уникальны в том плане, что могут **использоваться как в префиксной, так и в постфиксной форме.**

*При использовании префиксной формы операнд модифицируется перед выполнением операции. В постфиксной форме сначала
используется содержимое операнда, а лишь после этого операнд инкрементируется или декрементируется*.

*Пример:*

```java
class IncDec {

    public static void main(String args[]){

        int a = 1; 1
        int b = 2; 2
        int с = ++b; 3
        int d = a++; 1
        c++;
        System.out.print("a = " + a); // a = 2
        System.out.print("b = " + b); // b = 3
        System.out.print("c = " + c); // c = 4
        System.out.println("d = " + d); // d = 1

    }
}
```

## 8. Модификаторы доступа.

Всего есть 4 типа модификаторов доступа:

**public** - публичный, общедоступный класс или член класса. Поля и методы, объявленные с модификатором *public*,
видны другим классам из текущего пакета и из внешних пакетов.

**private** - закрытый класс или член класса, противоположность модификатору *public*.
Закрытый класс или член класса доступен только из кода в том же классе.

**protected** - такой класс или член класса доступен из любого места в текущем классе или пакете или в производных классах,
даже если они находятся в других пакетах

**default (package-private)** - отсутствие модификатора у поля или метода класса предполагает применение к нему модификатора по умолчанию.
Такие поля или методы видны всем классам в текущем пакете.

## 9. Основные принципы ООП.

**Абстракция**

Абстрагирование — это способ выделить набор значимых характеристик объекта, исключая из рассмотрения незначимые.
Абстракция — это набор всех таких характеристик.

*Пример*

*Люди не представляют себе автомобиль как набор десятков тысяч индивидуальных частей (деталей).
В их воображении автомобиль - хорошо определенный объект со своим собственным уникальным поведением.
Эта абстракция позволяет людям использовать автомобиль, не задумываясь над сложностью деталей, из которых он состоит.*

**Наследование**

С помощью наследования можно расширить функционал уже имеющихся классов за счет
добавления нового функционала или изменения старого при помощи переопределения (переменные переопределять нельзя,
только методы). Чтобы объявить один класс наследником от другого,
надо использовать слово *extends*. С помощью ключевого слова *super* можно обратиться к любому *неприватному
*члену базового класса - методу или полю.

В некоторых ситуациях применение наследования может быть нежелательным. В этом случае можно запретить
наследование с помощью слова `final`.

`public final class Person {}`

**Инкапсуляция**

Инкапсуляция предохраняет данные объекта от нежелательного доступа,
позволяя объекту самому управлять доступом к своим данным. Внутри объекта данные и методы могут
обладать различной степенью доступности. Степени доступности определяется
при помощи модификаторов доступа.

**Полиморфизм**

Суть полиморфизма заключается в том, что вы можете использовать наследников, как родителей.
При этом, если в классе-наследнике был переопределен какой — то метод, то вызовется он.

## 10. Абстрактные классы и интерфейсы.

**Абстрактный класс** - это класс, на основе которого нельзя создать объект. Однако можно создать переменную абстрактного типа:

`AbstractList a = new ArrayList();`

Если класс содержит хотя бы один абстрактный метод, то он обязан быть абстрактным.
В тоже время абстрактный класс не обязательно должен иметь только абстрактные методы.
Это бывает полезным в ситуациях, где в классе абстрактные методы просто не нужны,
но необходимо запретить создание экземпляров этого класса.

Модификатор *abstract* у метода означает, что этот метод не определен и вызывать его нельзя, но он должен быть переопределен
во всех наследниках класса. При наследовании (если наследник не абстрактный) от абстрактного класса,
компилятор выдает ошибку, если не переопределены все абстрактные методы абстрактного родителя.

Java разрешит описать конструкторы в абстрактных классах, но не разрешит ими воспользоваться
(потому что запрещено создавать объекты абстрактного класса). Конструктор может использоваться для инициализации полей.
К примеру, при создание объекта класса наследника от абстрактного класса будет вызвн конструктор класа наследника и
конструктор класса родителя (абстрактный).


**Абстрактные методы не могут быть статическими!**
(абстрактные методы должны быть переопределены в неабстрактных классах наследниках, статические методы не могут быть
переопределены.) Но сам по себе абстрактный класс может иметь статические методы.

**Интерфейсы** в Java напоминают классы, но могут содержать только константы, сигнатуры методов и вложенные типы.

Все поля по умолчанию являются `public static final`. `static` т.к нельзя создать объект интерфейса, `final` т.к
значение переменной нельзя изменить.

*Т.к интерфейс - это не класс, а набор правил и т.к нельзя создать объект интерфейса, то значение
переменных не может меняться, поэтому все переменные по умолчанию являются `final`, а методы `abstract`*

При попытке использования переменной с таким же именем будет происходить *сокрытие переменной*.

*Пример*


```java
public interface TestInterface {

    String band = "Metallica"; // по умолчанию public static final

}

public class Test implements TestInterface {

    private static String band = "SOAD"; // отдельная независимая переменная

    public static void main(String[] args) {

        System.out.println(band); // будет использована переменная класса Test

        Test t1 = new Test();
        TestInterface t2 = new Test();

        System.out.println(t1.band); // будет использована переменная по типу t1
        System.out.println(t2.band); // будет использована переменная по типу t2
    }

}
```

*Результат выполнения*

```java
SOAD
SOAD
Metallica
```

Все методы по умолчанию являются `public abstract` и не имеют реализации (фигурные скобки не пишутся).

*В Java 8 возможна реализация методов. Для этого необходимо отметить метод ключевым словом *default*.*

*Сам интерфейс может иметь модификаторы доступа только public или default.*

Нельзя создать объект типа интерфейса, но можно использовать интерфейс в качестве типа.

Можно использовать название интерфейса в качестве типа данных так же как и любые другие типы.
Если объявить переменную типа интерфеса, то можно присвоить ей объект любого класса, который реализует этот интерфейс.

Класс который реализует интерфейс, должен описывать все методы, объявленные в интерфейсе. Один класс может использовать несколько интерфейсов.
Интерфейс может наследовать другие интерфейсы, как классы могут наследовать другой класс.
В отличие от классов, интерфейсы могут наследовать любое количество других интерфейсов.

**Интерфейсы маркеры**

Иногда полезно определить пустой интерфейс. Класс может реализовать этот интерфейс, указав его в *implements*.
При этом нет необходимости реализовывать методы. Любой экземпляр класса становится экземпляром интерфейса.
С помощью оператора *instanceof* можно проверить, является ли объект экземпляром интерфейса.
Т.о, эта техника полезна для предоставления дополнительной информации об объекте.

**Интерфейс Cloneable из пакета java.lang является примером интерфейса-маркера (marker interface).**

Он не определяет методов, но идентифицирует класс, внутреннее состояние которого можно клонировать методом `clone()` класса *Object*.

**Еще одним примером интерфейса-маркера является интерфейс java.io.Serializable.**

Интерфейсы-маркеры использовались до того, как в Java 5 появились анотации.

*Пример:*

Дан произвольный объект. Наличие у него работающего метода `clone()` можно определить с помощью следующего кода:

```java
int[] aint = new int[10];
int[] bint;

if (aint instanceof Cloneable)
    bint = aint.clone();
else
    bint = null;
```

**Сравнение абстрактных классов и интерфейсов:**

<table>
    <thead>
        <tr>
            <th>Критерии сравнения</th>
            <th>Интерфейс</th>
            <th>Абстрактный класс</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Наследование классов</td>
            <td>Класс может реализовать множество интерфейсов</td>
            <td>Класс может наследовать только один абстрактный класс</td>
        </tr>
        <tr>
            <td>Поля данных</td>
            <td>Интерфейс может содержать только общедоступные константы - `public final static long SOME_CONST = 1`</td>
            <td>Абстрактный класс может содержать любые поля: статические и экземплярные, константы, *private/protected/public*</td>
        </tr>
        <tr>
            <td>Модификаторы доступа методов</td>
            <td>Методы в интерфейсе могут иметь модификаторы только *public* и *abstract*. По-умолчанию они уже *public abstract*</td>
            <td>К неабстрактным членам класса применимы любые модификаторы. Однако абстрактные методы *не могут быть приватными*</td>
        </tr>
        <tr>
            <td>Реализация объявленных методов</td>
            <td>Интерфейс не может содержать реализации методов</td>
            <td>Абстрактный класс допускает реализацию методов</td>
        </tr>
        <tr>
            <td>Описание конструктора</td>
            <td>Интерфейс не может содержать конструкторов, т.к нельзя создать объект интерфейса</td>
            <td>В абстрактном классе можно описать конструктор (или несколько конструкторов)</td>
        </tr>
    </tbody>
</table>

*С абстрактными классами теряется индивидуальность класса, наследующего его; с интерфейсами расширяется функциональность каждого класса.*

## 11. Вложенные классы.

Java позволяет создавать классы внутри других классов. Такие классы называются **вложенными**.

Вложенные классы могут быть **статичес
кими и нестатическими**. Статические классы называются -
**вложенные статические классы (nested static classes)**,
а нестатические классы - **внутренние классы (inner classes)**.
Так же есть два вида *внутренних классов*:
**локальные классы (local classes)** и **анонимные классы (anonymous classes)**.

![Java Nested Classes](http://jitendrazaa.com/blog/wp-content/uploads/2011/03/Types-of-Nested-Classes-in-JAVA.jpg)

```java
class OuterClass {
    ...
    static class StaticNestedClass {
        ...
    }
    class InnerClass {
        ...
    }
}
```

**Для чего нужны вложенные классы**

Вложенные классы используются в слудющих случаях:

1. Когда необходимо сгруппировать классы, логически принадлежащие друг другу.
Если один класс используется только другим классом, то логично будет сделать его вложенным.

2. Для улучшение инкапсуляции. К примеру есть класс *A* и класс *B*. Классу *B* нужно получить доступ к приватным членам
класса *A*. Это можно сделать, если поместить класс *B* в класс *A*, тогда у класса *B* будет доступ ко всем членам класса *A*.

3. Делает код более читаемым и поддерживаемым, т.к сразу видно какой класс от какого зависит.

**Статические вложенные классы (Static Nested Classes)**

Статические вложенные классы не имеют доступа к нестатическим полям и методам обрамляющего класса, что в некотором роде
аналогично статическим методам, объявленным внутри класса.
Доступ к нестатическим полям и методам может осуществляться только через ссылку на экземпляр обрамляющего класса.
Кроме этого, статические вложенные классы имеют доступ к любым статическим методам внешнего класса, в том числе и к приватным.

`OuterClass.StaticNestedClass`

*Пример создания объекта статического вложенного класса*

`OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();`

**Внутренние классы (Inner Classes)**

Внутренний класс связан с объектом обрамляющего класса и имеет доступ ко всем его полям и методам, в том числе статическим
и приватным. Внутренние классы не могут содержать статические полям и методы (могут содержать статические поля если они объявлены
как *final*).

Т.к как объект внутреннего класса не может существовать без объекта обрамляющего класса, то перед созданием его объекта
необходимо создать объект обрамляющего класса.

```java
OuterClass outerObject = new OuterObject();
OuterClass.InnerClass innerObject = outerObject.new InnerClass();
```

**Локальные классы (Local Classes)**

Локальные классы - это такой вид внутренних классов, которые могут быть объявлены в теле метода, в цикле for или условии if.
Чаще всего локальные классы объявляются в теле метода.

*Пример*

public class Clazz {
    private int data = 30; // instance variable

    void display(){

        final String localVariable = "final var"

        class LocalInnerClass {
            void msg() {
                System.out.println(data);
                System.out.println(localVariable);
            }
        }

        LocalInnerClass l = new LocalInnerClass();
        l.msg();

    }

    public static void main(String args[]) {

        Clazz obj = new Clazz();
        obj.display();

    }
}

Как видно из примера, внутренний локальный класс имеет доступ к переменным обрамляющего класса. Что касается локальных переменных,
то доступ есть только к *final* локальным переменным.

*Локальные классы, так же как и внутренние класс:*

- не могут содержать статические полям или методы (могут содержать статические поля, если они объявлены как final).
- имеют доступ ко всем методам и полям объекта обрамляющего класса


В случае, если локальный класс объявлен в статическом методе, то он имеет доступ только к статическим члена обрамляющего класса,
в противном случае будет ошибка компиляции - non-static variable regularExpression cannot be referenced from a static context.

Это сравнимо с тем, что статические методы не имеют доступа к нестатическим членам класса.

**Анонимные классы (Anonymous Classes)**

Анонимные классы позволяют сократить код. Они позволяют объявлять и инициализировать класс в одно и то же время.
Анонимные классы похожи на локальные классы, только они не имеют имени.
Синтаксис создания анонимного класса базируется на использовании оператора new с именем класса (интерфейса) и телом новосозданного анонимного класса.
Основное ограничение при использовании анонимных классов - это невозможность описания конструктора, так как класс не имеет
имени. Аргументы, указанные в скобках, автоматически используются для вызова конструктора базового класса с теми же параметрами.

```java
class Clazz {
    Clazz(int param) { }

    public static void main(String[] args) {
        new Clazz(1) { }; // правильное создание анонимного класса
        new Clazz() { }; // неправильное создание анонимного класса
    }
}
```

*Случаи использования анонимных классов:*

- тело класса является очень коротким
- нужен только один экземпляр класса
- класс используется в месте его создания или сразу после него
- имя класса не важно и не облегчает понимание кода

## 12. Конструкторы.

Конструктор - это специальный метод, который вызывается при создании объекта. Не всегда удобно инициализировать
все переменные класса при создании его экземпляра. Иногда проще, чтобы какие-то значения были бы созданы по умолчанию
при создании объекта. По сути конструктор нужен для автоматической инициализации переменных.

Конструктор инициализирует объект непосредственно во время создания. Имя конструктора совпадает с именем класса, а по
синтаксису конструктор похож на метод без возвращаемого значения.
У конструкторов нет типа возвращаемого результата - никакого, даже *void*, если возвращается тип *void*,
то это уже не конструктор, а метод, несмотря на совпадение с именем класса.

Конструктор имеется в любом классе. Даже если не указан, то компилятор сам создаст конструктор по умолчанию
*(default constructor)*, который будет пустым и не делает ничего, кроме вызова конструктора суперкласса.
Конструктор похож на метод, но не является методом, он даже не считается членом класса.
*Поэтому его нельзя наследовать или переопределить в подклассе.*

В конструкторе допускается оператор *return*, но только пустой, без всякого возвращаемого значения.

Конструктор может иметь любой модификатор доступа. Если не указать напрямую, то по умолчанию будет *default*.
Модификатор *private* используется для создания *singleton* объектов.

## 13. Ключевое слово super.

В Java существует ключевое слово *super*, которое обозначает суперкласс, т.е. класс, производным от которого является текущий класс.
Ключевое слово *super* можно использовать для вызова конструктора суперкласса и для обращения к члену суперкласса, скрытому членом подкласса.

Ключевое слово *super* вызывает конструктор родительского класса. Если используется, то должно быть первой строкой в конструкторе.
Если конструктор не делает вызов конструктора *super* класса-предка (с аргументами или без аргументов),
компилятор автоматически добавляет код вызова конструктора класса-предка без аргументов.

*Нельзя использовать ключевое слово super в static методах.*

## 14. Статические члены класса

Модификатор *static* может использоваться *классом(вложенный), переменной, методом или блоком кода*.

**Статические переменные и методы**

Статическая переменная или метод или блок кода в классе - не определенный для конкретного экземпляра и нет никакой
необходимости создавать объект класса, чтобы обратиться к статическому члену класса.
Есть только одна копия статической области на класс - независимо от того, сколько экземпляров класса создано, поэтому
обращаться к статическим членам класс необходимо через имя класса.

- Статические методы класса вызываются только статическими методами.
- Статический метод не имеет *this*
- Статический метод не может быть переопределен нестатическим методом

Нельзя переопределять статические методы. Если объявить такой же метод в классе-наследнике,
произойдет **сокрытие метода (hiding methods)** суперкласса вместо его переопределения.

*Это означает, что при обращении к статическому методу, который объявлен как в родительском, так и в дочернем классе,
во время компиляции всегда будет вызван метод исходя из типа переменной.*

*Пример:*

```java
public class A {
    public static void testStatic(){
        System.out.println("Inside parent");
    }
}

public class B extends A {
    public static void testStatic() {
        System.out.println("Inside Child");
    }
    public static void main(String[] args) {
        A b = new A();
        A b1 = new B();
        B b2 = new B();
        b.testStatic(); // Inside parent
        b1.testStatic(); // Inside parent
        b2.testStatic(); // Inside Child
    }
}
```

Происходит это потому, что выбор вызываемого статического метода происходит при **раннем связывании** (т.е на этапе компиляции, а не во время выполнения).

*Чтобы из статического метода вызвать нестатический метод, нужно создать экземпляр класса.*

```java
class Class1 {

     int total = 0;

     public static void main( String[] args ) {
         doIt(); // ошибка компиляции, правильно будет (new Class1()).doIt();
     }

     void doIt() {
        ...
    }
}
```

**Статические блоки**

Статический блок инициализации выполняется всего лишь один раз, когда класс впервые загружается и может только
инициализировать статические члены данного класса.

*Статический блок обычно нужен когда необходимо что-либо проинициализировать ещё до конструктора и до переменных класса*

## 15. Порядок конструирования объекта.

`public class Child extends Parent`

- Статические поля и статические блоки инициализации класса Parent (в порядке, в котором они указаны в классе);
- Статические поля и статические блоки инициализации класса Сhild(в порядке, в котором они указаны в классе);
- Нестатические поля класса Parent;
- Нестатические блоки инициализации класса Parent;
- Конструктор класса Parent;
- Нестатические поля  класса Сhild;
- Нестатические блоки инициализации класса Сhild;
- Конструктор класса Сhild.

*Статические блоки инициализации выполняются при загрузке класса до вызова метода `main()`G.*

*Пример*

```java
public class Parent {

    public Parent() {
        System.out.println("Public Default Parent Constructor");
    }

    {
        System.out.println("Parent Object Initialization Block 1");
    }

    static {
        System.out.println("Parent Static Block 1");
    }

    static {
        System.out.println("Parent Static Block 2");
    }

    {
        System.out.println("Parent Object Initialization Block 2");
    }

}

public class Child extends Parent {

    public Child() {
        System.out.println("Public Default Child Constructor");
    }

    public Child(String name) {
        System.out.println(name);
    }

    {
        System.out.println("Child Object Initialization Block 1");
    }

    static {
        System.out.println("Child Static Block 1");
    }

    static {
        System.out.println("Child Static Block 2");
    }

    {
        System.out.println("Child Object Initialization Block 2");
    }

    public static void main(String[] args) {
        Child child = new Child();
        System.out.println("====================================");
        Child child1 = new Child("Overloaded Constructor");
    }

}
```

*Результат выполнения*

```java
Parent Static Block 1
Parent Static Block 2
Child Static Block 1
Child Static Block 2
Parent Object Initialization Block 1
Parent Object Initialization Block 2
Public Default Parent Constructor
Child Object Initialization Block 1
Child Object Initialization Block 2
Public Default Child Constructor

====================================

Parent Object Initialization Block 1
Parent Object Initialization Block 2
Public Default Parent Constructor
Child Object Initialization Block 1
Child Object Initialization Block 2
Overloaded Constructor
```

**Как видно, инициализация статических блоков происходит всего лишь один раз, при загрукзе класса.**

## 16. Статическое и диманическое связывание.

**Статическое связывание**

Когда тип объекта определяется на этапе компиляции - это называется *статическое связывание (раннее связывание)*.
Статическое связывание относится к *static, private, final методам, а так же к перегрузке методов*.

*Пример*

```java
class Human {

   public static void walk() {
       System.out.println("Human walks");
   }

}
class Boy extends Human{

   public static void walk() {
       System.out.println("Boy walks");
   }

   public static void main( String args[]) {
       Human boy = new Boy();
       boy.walk(); // Human walks
   }

}
```

Т.к копилятор знает, что *static, private, final* методы не могут быть переопределены (в данном примере происходит
сокрытие статического метода, а не переопределение), то всегда будет вызывать методы по типу ссылки, т.е у класса *Human*.

Так же статическое связывание работает при перегрузке методов.

```java
public class Boy extends Human {

    public static void test(Human human) {
        System.out.println("I am human");
    }

    public static void test(Boy boy) {
        System.out.println("I am boy");
    }

    public static void main(String[] args) {
        Human boy = new Boy();
        test(boy); // I am human
    }

}
```

В данном примере перегруженный метод будет выбран на основании типа ссылки - *Human*.

**Динамическое связывание**

В случае если на этапе компиляции неизвестно какой метод будет вызван (парента или чаилда), то это называется -
*динамическое связывание (позднее связывание)*. Какой метод должен быть вызван определяется на этапе выполнения программы.

*Пример*

```java
public class Human {

    public void walk(){
        System.out.println("Human walks");
    }

}

public class Boy extends Human {

    @Override
    public void walk() {
        System.out.println("I am boy");
    }

    public static void main(String[] args) {
        Human boy = new Boy();
        boy.walk(); // I am boy
    }

}
```

В данном примере метод будет вызван **по типу объекта**.

**Так же важно знать, что при обращении к поля класса, позднее связывание срабатывать не будет**

*Пример*

```java
public class Human {

    public String name = "Human Name";

    public String getName() {
        return name;
    }

}

public class Boy extends Human {

    public String name = "Boy Name";

    public String getName() {
        return name;
    }

    public static void main(String[] args) {
        Boy boy = new Boy();
        Human human = boy;
        System.out.println(human.name); // Human Name
        System.out.println(human.getName()); // Boy Name
    }

}
```

Можно было бы предположить, что так же как и в предыдущем примере будет обращение к переменной по типу объекта, но на самом
деле обращение к полям класса происходит по типу ссылки.

*В первом случае позднее связывание не срабатывает, во втором срабатывает.*

```java
System.out.println(human.name); // Human Name
System.out.println(human.getName()); // Boy Name
```

**Основные отличия статического и динамического связывания**

- Статическое связывание вызывается на этапе компиляции, в то время как динамическое во время выполнения программы
- Связывание private, final и static методов всегда выполняется на этапе компиляции, т.к эти методы не могут быть
    переопределены. Связывание переопределенных методов происходит во время выполнения программы
- Java использует статическое связывание при перегрузке методов и динамическое связывание при переопределении методов

## 17. Класс Object.

*Object* - это базовый класс для всех остальных классов в Java. Каждый класс наследуется от *Object*.
Соответственно, все классы наследуют методы класса *Object*.

11 методов класса *Object*:

- `public final native Class getClass()`
- `public native int hashCode()`
- `public boolean equals(Object obj)`
- `protected native Object clone() throws CloneNotSupportedException`
- `public String toString()`
- `public final native void notify()`
- `public final native void notifyAll()`
- `public final native void wait(long timeout) throws InterruptedException`
- `public final void wait(long timeout, int nanos) throws InterruptedException`
- `public final void wait() throws InterruptedException`
- `protected void finalize() throws Throwable`

**getClass()** - этот метод возвращает объект класса *Class*, который описывает класс(имя, методы, поля), на основе
которого создан объект. Метод `getClass()` позволяет получить тип данного объекта.

**hashCode()** - данный метод возвращает значение *int*.
Цель `hashCode()` – представить любой объект целым числом. Нельзя гарантировать, чтобы различные объекты
возвращали различные хэш-коды, но, необходимо, чтобы объекты, равные по значению
(метод `equals()` возвращает *true* ), возвращали одинаковые хэш-коды.

**equals()** - сравнивает объекты на эквивалетность.

**clone()** - при выполнении метода `clone()` сначала проверяется, можно ли клонировать исходный объект
(для того, что сделать объекты класса доступными для клонирования через, необходимо реализовать интерфейс-маркер *Cloneable*)
Если проверка не выполняется, метод выбрасывает *CloneNotSupportedException*.
Если интерфейс *Cloneable* реализован, то создается новый объект от того же класса, от которого был создан исходный объект.
При этом копирование выполняется на уровне виртуальной машины, никакие конструкторы не вызываются.
Затем значения всех полей, объявленных, унаследованных либо объявленных в родительских классах, копируются.
Полученный объект возвращается в качестве клона.

Примитивные поля копируются по значению и существуют независимо в исходном и клонированном объектах.
Ссылочные поля копируются по ссылке, оба объекта ссылаются на одну и ту же область памяти (исходный объект).
Поэтому изменения, происходящие с исходным объектом, сказываются на клонированном.

*Важно знать, что сам класс *Object* не реализует интерфейс *Cloneable*, а потому попытка вызова `new Object().clone()`
будет приводить к ошибке.*

**toString()** - позволяет получить текстовое описание любого объекта. Создавая новый класс,
данный метод можно переопределить и возвращать более подробное описание.
Для класса *Object* и его наследников, не переопределивших `toString()`, метод возвращает следующее:

`getClass().getName()+"@"+hashCode()`

**finalize()** - вызывается при уничтожении объекта сборщиком мусора (garbage collector).
В классе *Object* не имеет реализации, однако в классе-наследнике позволяет описать все действия,
необходимые для выполнения перед удалением объекта, такие как закрытие соединений с БД, сетевых соединений,
снятие блокировок на файлы и т.д. В обычном режиме напрямую этот метод вызывать не нужно, он вызовется автоматически.
Если необходимо, можно обратиться к нему явным образом. В методе `finalize()` нужно описывать только
дополнительные действия, связанные с логикой работы программы. Все необходимое для удаления объекта *JVM* сделает сама.

## 18. Методы hashCode() и equals().

Методы `hashCode()` и `equals()` - это методы из класса *Object*.

- `public native int hashCode()`
- `public boolean equals(Object obj)`

**Метод hashCode()**

**Хеширование** - это способ преобразования любой *переменной/объекта* в уникальный код после применения формулы/алгоритма к их свойствам.

В методе `hashCode()` ключевое слово *native* говорит о том, что реализация этого метода написана на другом языке программирования.
Этот метод возвращает хеш-код полученный путем конвертации внутреннего адреса объекта в число, что ведет к созданию
уникального кода для каждого отдельного объекта.

Важно понимать, что у хеш-код есть свой предел, т.к в Java хеш-код представлен в виде числа примитивного типа *int*,
который равен 4-м байтам, и может быть любым числом из диапазона `[-2 147 483 648; 2 147 483 647]`.

Следует понимать, что множество возможных хеш-кодов ограничено примитивным типом *int*, а множество объектов ограничено
только нашей фантазией. Отсюда следует утверждение, что

*множество объектов мощнее множества хеш-кодов*.

Из-за этого ограничения, вполне возможна ситуация, что хеш-коды разных объектов могут совпасть.

Отсюда получается, что:

- *Если хеш-коды разные, то и входные объекты гарантированно разные*.
- *Если хеш-коды равны, то входные объекты не всегда равны*.

Ситуация, когда у разных объектов одинаковые хеш-коды называется — **коллизией**.
Вероятность возникновения коллизии зависит от сложности используемого алгоритма генерации хеш-кода.

Если во время работы приложения несколько раз обратиться к одному и тому же объекту, то метод `hashCode()` должен постоянно
возвращать одно и то же значение.

Одинаковые объекты — это объекты одного класса с одинаковым содержимым полей.

- для одного и того-же объекта, хеш-код всегда будет одинаковым.

![equals and hashcode](http://habrastorage.org/storage2/327/99e/852/32799e852be1ded2b3d51b83383fe770.png)

- если объекты одинаковые, то и хеш-коды одинаковые (но не наоборот, см. следующий пункт).

![equals and hashcode](http://habrastorage.org/storage2/38f/6dd/d12/38f6ddd128c0371f0586d157a562b1ae.png)

- если хеш-коды равны, то входные объекты не всегда равны - *коллизия*.

![equals and hashcode](http://habrastorage.org/storage2/9b8/bc9/b8f/9b8bc9b8f37b20833b93a05789542928.png)

- если хеш-коды разные, то и объекты гарантированно разные

![equals and hashcode](http://habrastorage.org/storage2/eee/67b/6be/eee67b6bef6ac950fc8d03c1df194a9a.png)

**Метод equals()**

в Java, каждый вызов оператора `new` создает новый объект в памяти.

*Пример*

```java
public class BlackBox {

    int varA;
    int varB;

    BlackBox(int varA, int varB){
        this.varA = varA;
        this.varB = varB;
    }

}
```

```java
public class AppBlackBox {
    public static void main(String[] args) {
        BlackBox object1 = new BlackBox(5, 10);
        BlackBox object2 = new BlackBox(5, 10);
    }
}
```

![equals and hashcode](http://habrastorage.org/storage2/870/38d/fb3/87038dfb376ab33458602ec9f2e61e48.png)

Во втором примере создается два объекта. Содержимое этих объектов эквивалентно.

Для проверки эквивалентности в классе *Object* существует метод `equals()`,
который сравнивает содержимое объектов и выводит значение *true*, если содержимое эквивалентно, и *false* — если нет.

`object1.equals(object2); // должно быть true, поскольку содержимое объектов эквивалентно`

Эквивалентность и хеш-код тесно связанны между собой, поскольку хеш-код вычисляется на основании содержимого объекта (значения полей)
и если у двух объектов одного и того же класса содержимое одинаковое, то и хеш-коды должны быть одинаковые.

```java
object1.equals(object2) // должно быть true
object1.hashCode() == object2.hashCode() // должно быть true
```

“Должно быть”, потому что если выполнить предыдущий пример, то результатом выполнения всех операций будет *false*.

Связано это с тем, что все классы наследуются от класса *Object*. В этом классе уже определены методы `hashCode()` и `equals()`.
Определяя свой класс, автоматически наследуется все методы класса *Object*, и в ситуации, когда в классе не
переопределены `hashCode()` и `equals()`, будут использованы реализации из *Object*.

Исходный код метода `equals()` в классе *Object*.

```java
public boolean equals(Object obj) {
    return (this == obj);
}
```

При сравнение объектов, операция `==` вернет *true* в случае, когда ссылки указывают на один и тот-же объект в памяти.
В данной реализации не учитывается содержимое полей.

Выполнив приведённый ниже код, `equals()` вернет *true*.

```java
public class DemoBlackBox {

    public static void main(String[] args) {
        BlackBox object3 = new BlackBox(5, 10);
        BlackBox object4 = object3; // Переменная object4 ссылается на тот-же объект, что и переменная object3
        System.out.println(object3.equals(object4)); // true
    }

}
```

![equals and hashcode](http://habrastorage.org/storage2/aad/751/9be/aad7519bec3bb721fa912b59b39436dc.png)

Теперь понято, почему `Object.equals()` работает не так как нужно, ведь он сравнивает ссылки, а не содержимое объектов.

Метод `hashCode()` тоже работает не так как полагается.
Исходный код метода `hashCode()` в классе *Object*:

`public native int hashCode();`

Используя реализацию метода `hashCode()` класса *Object*, при каждом создании `new BlackBox()`
будет создаваться разный хеш-код.

Поэтому, при создании пользовательского класса, принято переопределять методы `hashCode()` и `equals()` таким образом,
что бы учитывались поля объекта.

**Пример переопределения equals() и hashCode()**

```java
public class BlackBox {
    int varA;
    int varB;

    BlackBox(int varA, int varB){
        this.varA = varA;
        this.varB = varB;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + varA;
        result = prime * result + varB;
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        BlackBox other = (BlackBox) obj;
        if (varA != other.varA)
            return false;
        if (varB != other.varB)
            return false;
        return true;
    }
}
```

*В результате:*

```java
object1.equals(object2); // true
object1.hashCode() == object2.hashCode(); // true
```

Есть несколько правил по переопределению метода `hashCode()`:

- Это не должна быть константа.
- Метод генерации должен быть хорошо продуман, иначе могут часто попадаться ситуации коллизии.
- В генерации желательно использовать именно те поля, которые идентифицируют уникальность объекта.

**Считается правильным всегда переопределять hashCode(), если метод equals() был переопределен.**

В противном случае это нарушит контракт метода `hashCode()` и приведет к неправильной работе при использовании объектов этого
класса для хранения в любых структурах данных, основанных на хэш-таблице.

*Контракт, описанный в спецификации Java по поводу метода `hashCode()`:*

- Whenever it is invoked on the same object more than once during an execution of a Java application, the hashCode
method must consistently return the same integer, provided no information used in equals comparisons on the object is modified.
This integer need not remain consistent from one execution of an application to another execution of the same application.

- If two objects are equal according to the `equals(Object)` method, then calling the hashCode method on each of the two
objects must produce the same integer result.

- It is not required that if two objects are unequal according to the equals(java.lang.Object) method, then calling
the hashCode method on each of the two objects must produce distinct integer results. However, the programmer should
be aware that producing distinct integer results for unequal objects may improve the performance of hash tables.

Ключевым нарушением является второй пункт, который говорит о том, что два эквивалентных объекта должны иметь одинаковые хэш-коды.

*Что будет, если хранить объекты без переопределенного хэш-кода в структурах данных, основанных на хэш-таблице*

```java
public class User {

    private Integer id;
    private String email;

    public User(Integer id, String email) {
        this.id = id;
        this.email = email;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        User user = (User) o;

        if (email != null ? !email.equals(user.email) : user.email != null) return false;
        if (id != null ? !id.equals(user.id) : user.id != null) return false;

        return true;
    }

    // метод hashCode() не переопределен
}
```

```java
public class Main {

    public static void main(String[] args) {
        User user = new User(1, "user@gmail.com");

        Map<User, String> users = new HashMap<User, String>();
        users.put(user, "John Johnson");

        System.out.println(users.get(new User(1, "user@gmail.com"))); // null

    }

}
```

*Объяснение*

В результате будет *null*, даже не смотря на то, что метод `equals()` был переопределен. Связано это с тем, что при вызове
метода `put()`, у объекта `user` был вычислен хэш-код, на основании которого элемент был помещен в нужный бакет.

При попытке получить объект из `HashMap` по ключу `new User(1, "user@gmail.com")` сначало будет определен хэш-код
объекта `new User(1, "user@gmail.com")`, т.к метод `hashCode()` не переопределен, то хэш-коды у двух эквивалентных объектов
будут отличаться и поиск скорее всего будет выполняться в другом бакете.

Но, даже в случае если поиск будет проводиться в нужном бакете, то `get()` все равно вернет `null`, т.к метод `equals()`
вобще не будет вызван, т.к проверка хэшкодов у двух объектов вернет *false*.

## 19. Отличия equals() от ==.

Метод `equals()` обозначает отношение эквивалентности объектов. Эквивалентным называется отношение, которое является
*симметричным, транзитивным и рефлексивным*.

- **Рефлексивность**: для любого не *null x*, `x.equals(x)` вернет *true*;
- **Транзитивность**: для любого не *null x, y* и *z*, если `x.equals(y)` и `y.equals(z)` вернет *true*, тогда и `x.equals(z)` вернет *true*;
- **Симметричность**: для любого не *null x и y*, `x.equals(y)` должно вернуть *true*, тогда и только тогда, когда `y.equals(x)` вернет *true*.

Также для любого не *null x*, `x.equals(null)` должно вернуть *false*.
Отличия `equals()` от операции `==` в классе *Object* нет. Это видно, если взглянуть исходный код метода `equals()` класса *Object*:

```java
public boolean equals(Object obj) {
    return (this == obj);
}
```

Однако, нужно не забывать, что, если объект ни на что не ссылается *(null)*, то вызов метода `equals()` этого объекта приведет
к *NullPointerException*. Также нужно помнить, что при сравнении объектов по ссылке оба они могут быть *null* и операция `obj1 == obj2`
в данном случае будет *true*, а вызов `equals()` приведет к исключению *NullPointerException*.

*В целом, при помощи операции `==` сравнивается указывают ли ссылки на один и тот же объект, при помощи `equals()`
сравниваются значения объектов, в случае, если метод `equals()` был переопределен.*

## 20. Строки.

Классы *String, StringBuffer, StringBuilder* определены в пакете `java.lang` и доступны автоматически без объявления импорта.
Все три класса реализуют интерфейс *CharSequence*.

Следует знать, что объекты класса *String* являются *неизменяемыми*. Поэтому, когда при каждом изменении строк, на самом
будет создан новый объект. В Java есть специальные классы *StringBuffer* и *StringBuilder*, который допускают изменения в строке.

*Способы инициализации:*

```java
String s = "This is string";
String[] sArray = {"First", "Second", "Third"};
String str = new String(); // создается пустой объект класса String

char[] chars = { 'c', 'a', 't' };
String str = new String(chars); // создается строка через массив

char[] chars = {'c', 'a', 't', 'a', 'm', 'a', 'r', 'a', 'n' };
String str = new String(chars, 0, 3); // создание строки из массива через конструктор определенной длины
```

Можно создать объект класса *String* из объекта классов *StringBuffer* и *StringBuilder* при помощи следующих конструкторов:

```java
String(StringBuffer obj_StrBuf)
String(StringBuilder obj_StrBuild)
```

**Какие различия между String, StringBuffer и StringBuilder.**

Строка является *immutable* и *final*, поэтому любые изенения строки приводят к созданию нового объекта в памяти.
Манипуляции со строками ресурсоемкие, поэтому Java предоставляет два класса для манипуляций со строками – *StringBuffer и StringBuilder*.
*StringBuffer и StringBuilder* являются изменяемыми классами. Операции с *StringBuffer* потокобезопасны и синхронизированы,
а методы *StringBuilder* не потокобезопасны. Поэтому когда несколько потоков работают с одной строкой,
необходимо использовать *StringBuffer*, но в однопоточном приложении можно использовать *StringBuilder*.
*StringBuilder* более производительный, чем *StringBuffer*, поскольку не является синхронизированным.

*String* является *immutable* классом и у этого есть свои преимущества:

- строковый пул возможен только потому, что строка неизменна в Java, таким образом виртуальная машина сохраняет много
 места в памяти *(heap space)*, поскольку разные строковые переменные указывают на одну переменную в пуле.
 Если бы строка не была неизмененяемой, тогда бы интернирование строк не было бы возможным,
 потому что если какая-либо переменная изменит значение, это отразится также и на остальных переменных, ссылающихся на эту строку.

- Поскольку строка неизменная, её хэш-код кэшируется в момент создания и нет необходимости рассчитывать его снова.
Это делает строку отличным кандидатом для ключа в *Map* и его обработка будет быстрее, чем других ключей *HashMap*.

**Что такое пул строк?**

Пул строк – это набор строк, который хранится в памяти **Java heap**. Можно создавать объекты класса *String*,
используя оператор *new* точно так же, как и создавать объекты, предоставляя значение строки в двойных кавычках.

![String pool](http://info.javarush.ru/uploads/images/00/06/62/2014/02/07/569a94.png)

Пул строк помогает экономить большой объем памяти, но с другой стороны занимает больше времени.
Когда создается строка через двойные кавычки, сначала ищется строка в пуле с таким же значением,
если находится, то просто возвращается ссылка, иначе создается новая строка в пуле, а затем возвращается ссылка.

Когда используется оператор *new* объект будет создан не в пуле. Затем, используя метод `intern()`,
можно поместить строку в пул или получить из пула ссылку на другой объект *String* с таким же значением.

**Что делает метод intern()?**

При вызове метода `intern()` если пул строк уже содержит строку, эквивалентную объекту,
что подтверждается методом `equals()`, *будет возвращена ссылка на строку из пула*.

В противном случае объект строки добавляется в пул и ссылка на этот объект возвращается.

*Метод `intern()` всегда возвращает строку, которая имеет то же значение, что и текущая строка,
но гарантирует что это будет строка из пула уникальных строк.*

```java
public class StringPool {

    public static void main(String[] args) {

        String a = "string a";
        String b = new String("string a");
        String c = b.intern();

        System.out.println(a == b); // false
        System.out.println(b == c); // false
        System.out.println(a == c); // true
    }

}
```

```java
class Main {

    public static void main(String[] args) {

        Integer i = new Integer("10");

        if (i.toString().intern() == i.toString().intern())
            System.out.println("true");
        else
            System.out.println("false");

    }

}
```

*Результат выполнения:*

`true`

**Являются ли строки потокобезопасными в Java?**

Строки являются неизменными, поэтому нельзя изменить их значение в программе. Следовательно, они потокобезопасные
и могут использоваться в многопоточном окружении.

## 21. Integer Pool.

В Java есть *pool* целых чисел в промежутке `[-128; 127]`. Т.е. при создании объекта *Integer* в этом промежутке,
вместо того, чтобы каждый раз создавать новый объект, *JVM* берет их из пула.

*Примеры*

```java
Integer i1 = 10;
Integer i2 = 10;
System.out.println(i1 == i2); // true
```
Результатом будет *true*, т.к *i1* и *i2* ссылаются на один и тот же объект, который находится в пуле.

```java
Integer i1 = 130;
Integer i2 = 130;
System.out.println(i1 == i2); // false
```
Результатом будет *false*, т.к 130 не попадает в диапазон `[-128; 127]` и следовательно *i1* и *i2* указывают
на разные объекты в памяти.

```java
Integer i1 = new Integer(10);
Integer i2 = new Integer(10);
System.out.println(i1 == i2); // false
```
В данном случае создается 2 объекта при помощи *new()*.
Результат будет *false* т.к *i1* и *i2* указывают на разные объекты в памяти.

## 22. Неизменяемые классы.

**Неизменяемый класс (immutable)** - это класс, объект которого не может быть изменен. Вся информация, содержащаяся в каждом объекте,
устанавливается во время создания объекта и остается в таком состоянии до конца жизни объекта.

Преимущество таких объектов в том, что такие объекты без дополнительных усилий могут быть использованы затем в работе
с несколькими потоками и не нужно дополнительно синхронизировать доступ к ним.

*Примеры: String, Integer, Float, Double, BigInteger, BigDecimal, и т.д.*
*Все классы-обертки являются неизменяемыми.*

Для того, чтобы гарантировать неизменяемость класса, необходимо соблюдать следующие правила:

- Объявить класс как *final* (нельзя наследовать этот класс)
- Объявить поля класса как *final* (нельзя изменить значение после созданя объекта этого класса)
- Не создавать *setter* (нельзя изменить значение полей класса)

Неизменяемые классы могут содержать *геттеры и публичный конструктор*.

## 23. Переопределение методов.

При переопределении *(override)* методов сигнатуры методов должны совпадать, иначе будет выполняться перегрузка методов
*(overload)*.

При переопределении методов в классах наследниках можно:

- расширять модификатор доступа *(private-package -> protected -> public)*.
- изменять тип возвращаемого параметра *(ковариантность)*.
- можно изменить имена аргументов, но не тип.
- возможно изменить порядок в секции throws или убрать вовсе, но **нельзя сужать** (можно добавить `throws RuntimeException` в переопределенном методе).

**Нельзя сужать область видимости переопределенного метода (при попытке будет ошибка компиляции), но расширять можно**.

*Пример*

```java
lin
```

**Нельзя переопределять private методы. При переопределение статических методов будет выполняться сокрытие, а не переопределение.**

*Под ковариантностью подразумевается, что переопределённый метод может вернуть тип, производный от типа, возвращаемого методом базового класса.*

Предопределённая аннотация `@Override` используется для выявления логических ошибок на этапе компиляции.
Этой аннотацией желательно помечать каждый метод, который будет переопределять метод из суперкласса или реализовывать
метод из интерфейса. Если в суперклассе или интерфейсе нет метода с такой же сигнатурой, то возникнет ошибка компиляции.
Это позволяет легко выявлять ситуации, когда в суперклассе или интерфейсе была удалена или изменена сигнатура перекрываемого метода.
В противном случае во время компиляции генерируется сообщение об ошибке.

```java
public class MyClass {

   @Override
   public boolean equals(MyClass obj){
       return super.equals(obj);
   }

}
```

В приведенном выше примере при компиляции будет получено сообщение о том, что метод `equals()` класса *MyClass*
должен переопределять или реализовывать метод суперкласса.
В данном случае метод *equals()*, не переопределяет метод родительского класса *Object*,
т.к. у класса *Object* в метод `equals()` в качестве аргумента передается экземляр класса *Object*, а не *MyClass*.


Т.о, здесь выполняется перегрузка, а не переопределение, в связи с чем при компиляции будет сообщение об ошибке.

*В целом, для проверки подобных ситуаций и служит аннотация `@Override`.*

## 24. Перегрузка методов и конструкторов.

Каждый метод имеет свою сигнатуру.

**Сигнатура** - совокупность *имени метода с набором параметров*.
Причем *возвращаемое значение не входит в сигнатуру*, а порядок следования параметров - входит
(`save(String s, int i)` и `save(int i, String s)` - это методы с разными сигнатурами).

*Исключения не входят в сигнатуру метода*.

Java позволяет создавать несколько методов с одинаковыми именами, но с разными сигнатурами.
Создание метода с тем же именем, но с другим набором параметров называется перегрузкой.
Какой из перегруженных методов должен выполняться, будет определено на основе фактических параметров.

*Пример перегрузки метода*

```java
void print( double a) {
  System.out.println(a);
}
void print(String a) {
  System.out.println(a);
}
void print(int[] a) {
  for (int i=0; i<a.length; i++) {
    System.out.print(a[i]+" ")
  }
}
```

*Результат действия перегрузки метода*

```java
int a = 5;
int [] m = {1, 2, 8, 3}
String s = "Hello world";
print(a) // работает исходный метод
print(a+s); // 5 Hello world, работает первая перегрузка
print(m); // 1 2 8 3
print(m+a); // ошибка
```

Наряду с перегрузкой методов можно выполнять **перегрузку конструкторов**.
Конструкторов может быть несколько в классе. В этом случае конструкторы называют перегруженными.

Если в классе определен конструктор с параметрами, а конструктора без параметров нет, то вызов конструктора без параметров является ошибкой.

`User user = new User(); // wrong`

## 25. Передача параметров.

В Java параметры передаются по значению. В случае с объектами в метод передается ссылка на объект, но опять же по значению.

## 26. Разница между final, finally и finalize?

**final** - это ключевое слово в Java.

- Переменная, объявленная как final, инициализируется один раз и не может быть изменена (поле с модификатором *final*
    должно быть проинициализировано при объявлении либо значение должно быть присвоено в каждом конструкторе)
- Класс, объявленный как *final* не может быть унаследован.
- Метод, объявленный как *final* не может быть переопределен.

**finally** - это блок. Блок *finally* необязательный и используется совместно с блоком *try/catch*.
Блок *finally* гарантированно всегда выполняется внезависимости от того было выброшено исключение или нет.
Но блок *finally* полезен не только для обработки исключений, *finally* может быть использован для закрытия файлов или
для освобождения других системных ресурсов таких, как соединения с базой данных.

**finalize()** - метод, который вызывается перед тем, как объект будет уничтожен сборщиком мусора.

## 27. Пакеты.

Как правило, в Java классы объединяются в пакеты. Пакеты позволяют логически структурировать классы.
По умолчанию java имеет ряд встроенных пакетов, например,

```java
java.lang
java.util
java.io
```

и т.д. Кроме того, пакеты могут иметь вложенные пакеты.

Организация классов в виде пакетов позволяет избежать конфликта имен между классами.
Принадлежность к пакету позволяет гарантировать однозначность имен.

Чтобы указать, что класс принадлежит определенному пакету, надо использовать директиву package, после которой указывается имя пакета:

```java

package bookstore;

public class BookStore {

    public static void main(String[] args) {

    }
}

```

В данном случае класс *BookStore* находится в пакете *bookstore*. При определении классов в пакеты на жестком диске
эти классы должны размещаться в подкаталогах, путь к которым соответветствует названию пакета.
Например, в данном случае файл *BookStore.java* будет находиться в каталоге *bookstore*.

Классы необязательно определять в пакеты. Если для класса пакет не определен, то считается, что данный класс
находится в пакете по умолчанию, который не имеет имени.

**Импорт пакетов и классов**

Если нам надо использовать классы из других пакетов, то подключить эти пакеты и классы.
Исключение составляют классы из пакета *java.lang* (например, *String*), которые подключаются автоматически.

Например, класс *Scanner* находится в пакете `java.util`, поэтому можно получить к нему доступ следующим способом:

```java
java.util.Scanner in = new java.util.Scanner(System.in);
```

Т.е необходимо указывать полный путь к файлу. Однако это не удобно и в качестве альтернативы можно импортировать
пакеты и классы с помощью директивы *import*, которая указывается после директивы *package*:

```java
package bookstore;

import java.util.Scanner; // импорт класса Scanner

public class BookStore {

    public static void main(String[] args) {

        Scanner in = new Scanner(System.in);
    }
}
```

Директива *import* указывается в самом начале кода, после чего идет имя подключаемого класса (в данном случае класса *Scanner*).

В примере выше был подключен только один класс, однако пакет *java.util* содержит еще классы.
И чтобы не подключать по отдельности каждый класс, можно сразу подключить весь пакет:

```java
import java.util.*; // импорт всех классов из пакета java.util
```

Теперь можно использовать любой класс из пакета `java.util`.

Возможна ситуация, когда используются два класса с одним и тем же названием из двух разных пакетов, например,
класс *Date* имеется и в пакете `java.util`, и в пакете `java.sql`. Если надо одновременно использовать два этих класса,
то необходимо указывать полный путь к этим классам в пакете:

```java
java.util.Date utilDate = new java.util.Date();
java.sql.Date sqlDate = new java.sql.Date();
```

**Статический импорт**

Также есть особая форма импорта - статический импорт. Для этого вместе с директивой `import` используется модификатор *static*:

```java
package bookstore;

import static java.lang.System.*;
import static java.lang.Math.*;

public class BookStore {

    public static void main(String[] args) {

        double result = sqrt(20);
        out.println(result);
    }
}
```

Здесь происходит статический импорт классов *System* и *Math*. Эти классы имеют статические методы.
Благодаря статическому импорту можно использовать эти методы без названия класса.

Например, не `Math.sqrt(20)`, а `sqrt(20)`, так как метод `sqrt()` является статическим.

То же самое в отношении класса *System*: в нем определен статический объект *out*, поэтому мы можем его использовать без указания класса.

## 28. Исключения.

Существует специальный класс для исключений `java.lang.Trowable`.

Все классы, обрабатывающие ошибки, являются наследниками класса *Throwable*.
Только объекты этого класса или его наследников могут быть "выброшены" JVM при возникновении исключительной ситуации,
а также только эти объекты могут быть "выброшены" во время выполнения программы с помощью ключевого слова *throw*.

Его наследуют два класса `java.lang.Exception` и `java.lang.Error`.

Класс *Exception* используется для обработки исключений в программе. Можно наследоваться от него для создания
собственных типов исключений.

Для распространённых ошибок уже существует класс **RuntimeException**, который может обрабатывать деление на ноль или
определять ошибочную индексацию массива и т.д.

Класс *Error* служит для обработки ошибок в самом языке Java и на практике с ним не приходиться иметь с ним дело.

**Есть два вида исключений**

- checked
- unchecked

**Checked** исключения - это те, которые должны обрабатываться блоком *try/catch/finally* или описываться в сигнатуре метода через *throws*.
*Unchecked* могут не обрабатываться и не быть описанными.

**Unchecked** - это исключения, наследованные от *RuntimeException* и *Error*, *checked* - от *Exception* (не включая *unchecked*).

*Почему не все исключения являются проверяемыми?*

Если проверять каждое место, где теоретически может быть ошибка, то код станет плохо читаемым.
Например в любом месте, где происходит деление чисел, нужно было бы проверять на *ArithmeticException*, потому что возможно деление на ноль.
Эту опцию (переотлавливать непроверяемые исключения) создатели языка оставили разработчику на его усмотрение.

**Иерархия исключений**

![java exceptions](http://i.piccy.info/i9/7af03d28ef2e4d7fe98e8d116b97afaa/1398970263/78276/740281/exceptions_1200.jpg)

Существует пять ключевых слов, используемых в исключениях: **try, catch, throw, throws, finally.**<br/>

- *try* - данное ключевое слово используется для отметки начала блока кода, который потенциально может привести к ошибке.
- *catch* - ключевое слово для отметки начала блока кода, предназначенного для перехвата и обработки исключений.
- *finally* - ключевое слово для отметки начала блока кода, которое является дополнительным.
Этот блок помещается после последнего блока *catch*. Управление передаётся в блок *finally* в любом случае.
- *throw* - служит для генерации исключений.
- *throws* - ключевое слово, которое прописывается в сигнатуре метода, и обозначающее что метод потенциально может выбросить исключение с указанным типом.

*Порядок обработки исключений следующий:*

```java
try {
    // код, который потенциально может привести к ошибке
}
catch (тип_исключения_1 exceptionObject) {
    // обрабатываем ошибку
}
catch (тип_исключения_2 exceptionObject) {
    // обрабатываем ошибку
}
finally {
    // выполняется в любом случае (опциональный)
}
```

*Пример для вычисления площади прямоугольника:*

```java
public static void main(String[] args) {
    System.out.println(getAreaValue(-1, 100));
}

public static int getAreaValue(int x, int y){
    if(x < 0 || y < 0)
        throw new IllegalArgumentException("value of 'x' or 'y' is negative: x = " + x + ", y = " + y);
    return x*y;
}
```

Здесь метод `getAreaValue()` выбрасывает исключение *IllegalArgumentException* с помощью ключевого слова *throw*.
В данном случае в сигнатуре метода отсутствует `throws IllegalArgumentException`, т.к *IllegalArgumentException* является *unchecked exception*.

**Блок finally**

Иногда требуется гарантировать, что определенный участок кода будет выполняться независимо от того,
какие исключения были возбуждены и перехвачены. Для создания такого участка кода используется ключевое слово *finally*.
Даже в тех случаях, когда в методе нет соответствующего возбужденному исключению раздела *catch*, блок *finally* будет
выполнен до того, как управление перейдет к операторам, следующим за разделом *try*.

**У каждого раздела try должен быть по крайней мере или один раздел catch или блок finally**.

Блок *finally* очень удобен для закрытия файлов и освобождения любых других ресурсов, захваченных для временного
использования в начале выполнения метода. Ниже приведен пример класса с двумя методами, завершение которых происходит
по разным причинам, но в обоих перед выходом выполняется код раздела *finally*.

*Пример:*

```java
class FinallyDemo {
    static void procA() {
        try {
            System.out.println("inside procA");
            throw new RuntimeException("demo");
        } finally {
            System.out.println("procA's finally");
        }
    }
    static void procB() {
        try {
            System.out.println("inside procB");
            return;
        } finally {
            System.out.println("procB's finally");
        }
    }
    public static void main(String args[]) {
        try {
            procA();
        } catch (Exception e) {
        }
        procB();
    }
}
```

*Результат выполнения:*

```java
inside procA
procA's finally
inside procB
procB's finally
```

*Объяснение*

В методе `procA()` из-за возбуждения исключения происходит преждевременный выход из блока *try*, но по пути
выполняется блок *finally*. Второй метод `procB()` завершает работу выполнением стоящего в *try-блоке* оператора *return*,
но и при этом перед выходом из метода выполняется программный код блока *finally*.

**Обработка нескольких исключений**

Одному блоку *try* может соответствовать сразу несколько блоков *catch* с разными классами исключений.

```java
class Main {
    public static void main(String[] args) {
        FileInputStream fis = null;

        try {
            fis = new FileInputStream(fileName);
        }

        catch (FileNotFoundException ex) {
            System.out.println("Oops, FileNotFoundException caught");
        }

        catch (IOException e) {
            System.out.println("IOEXCEOTION");
        }
    }
}
```

Здесь если файл не найден, то будет выведено на экран `Oops, FileNotFoundException caught` и программа продолжит работать(в данном случае завершится),
если же файл найден, но, например, он не доступен для записи то на экран будет выведено `IOEXCEOTION`.
Важная особенность, **последовательность блоков catch должна идти от частного к более общему. В противном случае будет ошибка компиляции.**

```java
try {
    fis = new FileInputStream(fileName);
}

catch (Exception ex) {
    // do something
}

catch (IOException e) { // <--- Ошибка
    // do something
}
```

В **Java 7** стала доступна новая конструкция, с помощью которой можно переотлавливать несколько исключений одни блоком *catch*:

```java
try {
 ...
}

catch( IOException | SQLException ex ) {
  logger.log(ex);
  throw ex;
}
```

Это удобно, если обработка ошибок не отличается.

**Создание своих классов исключений**

Хотя встроенные исключения Java обрабатывают большинство частых ошибок, вероятно, вам потребуется создать ваши
собственные типы исключений для обработки ситуаций, специфичных для ваших приложений.
Это достаточно просто сделать - нужно наследоваться от *Exception* (этот класс наследуется от *Throwable*) и переопределить нужные методы класса *Throwable*.

**Встроенные исключения Java**

Существуют несколько готовых системных исключений. Большинство из них являются подклассами типа
*RuntimeException* и их не нужно включать в список *throws*. Вот небольшой список непроверяемых исключений.

- ClassNotFoundException - класс не найден
- CloneNotSupportedException - попытка клонировать объект, который не реализует интерфейс Cloneable
- IllegalAccessException - запрещен доступ к классу
- InstantiationException - попытка создать объект абстрактного класса или интерфейса
- InterruptedException - поток прерван другим потоком
- NoSuchFieldException - запрашиваемое поле не существует
- NoSuchMethodException - запрашиваемый метод не существует
- ReflectiveOperationException - исключение, связанное с рефлексией

Список проверяемых системных исключений, которые можно включать в список *throws*.

- ArithmeticException - арифметическая ошибка, например, деление на нуль
- ArrayIndexOutOfBoundsException - выход индекса за границу массива
- ArrayStoreException - присваивание элементу массива объекта несовместимого типа
- ClassCastException - неверное приведение
- EnumConstantNotPresentException - попытка использования неопределённого значения перечисления
- IllegalArgumentException - неверный аргумент при вызове метода
- IllegalMonitorStateException - неверная операция мониторинга
- IllegalStateException - некорректное состояние приложения
- IllegalThreadStateException - запрашиваемая операция несовместима с текущим потоком
- IndexOutofBoundsException - тип индекса вышел за допустимые пределы
- NegativeArraySizeException - создан массив отрицательного размера
- NullPointerException - неверное использование пустой ссылки
- NumberFormatException - неверное преобразование строки в числовой формат
- SecurityException - попытка нарушения безопасности
- StringIndexOutOfBounds - попытка использования индекса за пределами строки
- TypeNotPresentException - тип не найден
- UnsupportedOperationException - обнаружена неподдерживаемая операция

## 29. Generics.

**Обобщённое программирование** — это подход к описанию данных и алгоритмов, который позволяет их использовать с
различными типами данных без изменения их описания. В Java, начиная с версии *J2SE 5.0*, добавлены средства обобщённого
программирования - **generics (обобщения)**.

**Generics** - это параметризованные типы. С их помощью можно объявлять классы, интерфейсы и методы,
где тип данных указан в виде параметра. *Generics* добавили в язык безопасность типов.

Прежде чем перейти к рассмотрению обобщенных типов, рассмотрим проблему, которая могла возникнуть до появления *generics*:

```java
class BoxPrinter {
    private Object val;

    public BoxPrinter(Object arg) {
        val = arg;
    }

    public String toString() {
        return "{" + val + "}";
    }

    public Object getValue() {
        return val;
    }
}

class Test {
    public static void main(String[] args) {

        BoxPrinter value1 = new BoxPrinter(new Integer(10));
        System.out.println(value1);
        Integer intValue1 = (Integer) value1.getValue();
        BoxPrinter value2 = new BoxPrinter("Hello world");
        System.out.println(value2);
        Integer intValue2 = (Integer) value2.getValue(); // ошибка времени выполнения - переменной типа Integer присваивается значение типа String

    }
}
```

Реализация этого же функционала, но с использованием дженериков (и повторим ту же ошибку):

```java
class BoxPrinter<T> {
    private T val;

    public BoxPrinter(T arg) {
        val = arg;
    }

    public String toString() {
        return "{" + val + "}";
    }

    public T getValue() {
        return val;
    }
}

class Test {
    public static void main(String[] args) {

        BoxPrinter<Integer> value1 = new BoxPrinter<Integer>(new Integer(10));
        System.out.println(value1);
        Integer intValue1 = value1.getValue();
        BoxPrinter<String> value2 = new BoxPrinter<String>("Hello world");
        System.out.println(value2);

        Integer intValue2 = value2.getValue(); // ошибка компиляции

    }
}
```
Ошибка компиляции «лучше» ошибки времени выполнения -  *это очевидное достоинство дженериков.*

`class BoxPrinter<T>`

После имени класса в угловых скобках "<" и ">" указано имя типа `Т`, которое может использоваться внутри класса.
Фактически `Т` – это тип, который должен быть определён позже (при создании объекта класса). Угловые скобки указывают,
что параметр может быть обобщён. *Сам класс при этом называется обобщённым классом или параметризованным типом*.

Обычно для коллекций используется буква **E**, буквами **K**
и **V** - типы ключей и значение (Key/Value), а буквой **T** (и при необходимости буквы **S** и **U**) - любой тип.*

`private T val;`

Здесь объявляется переменная дженерик-типа (generic type), т.о. её тип будет указан позже, при создании объекта класса *BoxPrinter*.

`BoxPrinter<Integer> value1 = ...`

Здесь указывается, что `Т` имеет тип `Integer`. Грубо говоря, для объекта `value1` все поля `Т`-типа его класса `BoxPrinter`
становятся полями типа `Integer`.

Можно указать два и более параметров типа через запятую.

```java
class Pair<T1, T2> {
    T1 object1;
    T2 object2;

    Pair(T1 one, T2 two) {
        object1 = one;
        object2 = two;
    }

    public T1 getFirst() {
        return object1;
    }

    public T2 getSecond() {
        return object2;
    }
}

class Test {
    public static void main(String[] args) {
        Pair<Integer, String> pair = new Pair<Integer, String>(6, "Apr");
        System.out.println(pair.getFirst() + pair.getSecond());
    }
}
```

Нет ограничений и на количество переменных использующих такой тип.

```java
class PairOfT<T> {

    T object1;
    T object2;

    PairOfT(T one, T two) {
        object1 = one;
        object2 = two;
    }

    public T getFirst() {
        return object1;
    }

    public T getSecond() {
        return object2;
    }

}
```

Если типы не будут совпадать, то получим ошибку при компиляции:

`Pair<Integer, String> pair = new Pair<String, String>(6, " Apr");`

в Java 7 был введён **алмазный синтаксис (diamond syntax)**, в котором можно опустить параметры типа.
Т.е. можно предоставить компилятору определение типов при создании объекта. Вид упрощённого объявления:

`Pair<Integer, String> pair = new Pair<>(6, " Apr");`

*Как нельзя использовать generics*:

- нельзя использовать со статическими переменными универсальных параметров: `static T account;`
- нельзя создавать экземпляры универсальных классов следующим образом: `account = new T();`

**Универсальные методы (Generic methods)**

По аналогии с универсальными классами (дженерик-классами), можно создавать универсальные методы (дженерик-методы),
то есть методы, которые принимают общие типы параметров. Универсальные методы не надо путать с методами в дженерик-классе.
Универсальные методы удобны, когда одна и та же функциональность должна применяться к различным типам.
(Например, есть многочисленные общие методы в классе `java.util.Collections`.)

*Пример универсального метода:*

```java
class Utilities {
    public static <T> void fill(List<T> list, T val) {
        for (int i = 0; i < list.size(); i++)
            list.set(i, val);
    }
}

class Test {
    public static void main(String[] args) {

        List<Integer> intList = new ArrayList<Integer>();
        intList.add(1);
        intList.add(2);

        System.out.println("Список до обработки дженерик-методом: " + intList);

        Utilities.fill(intList, 0);

        System.out.println("Список после обработки дженерик-методом: " + intList);
    }
}
```

В первую очередь интересно это: `public static <T> void fill(List<T> list, T val) {...} `

`<T>` размещено после ключевых слов `public` и `static`, а затем следуют тип возвращаемого значения, имя метода и его параметры.
Такое объявление отлично от объявления универсальных классов, где универсальный параметр указывается после имени класса.

**Wildcards (Маски)**

```java
/*
* Данный код не скомпилируется из-за первой строки. На его примере
* объясняется, почему он не должен компилироваться
*/
List<Number> intList = new ArrayList<Integer>();
intList.add(new Integer(10));
intList.add(new Float(10.0f));
```

Первая строка кода смотрится вполне логично, т.к. *ArrayList* наследуется от *List*, а *Integer* наследуется от *Number*.
Однако допуская такую возможность мы получили бы ошибку в третьей строке этого кода, ведь выделили список под *Integer*,
но такая реализация ссылки на него позволила бы вставить в список значение типа *Float* (которому надо больше памяти, чем *Integer*).
Итогом стала бы ошибка времени выполнения. Дженерики же предназначены для того, чтобы подобных ошибок избегать.
Для этого в *generics* используются *wildcards(маски)*.

Под *маской* подразумевается это выражение - `<?>`
`List<?> intList = new ArrayList<Integer>();`

*Пример кода использующего маску и пригодного к компиляции:*

```java
class Test {
    static void printList(List<?> list) {
        for (Object l : list)
            System.out.println("{" + l + "}");
    }

    public static void main(String[] args) {
        List<Integer> list = new ArrayList<>();
        list.add(10);
        list.add(100);
        printList(list);
        List<String> strList = new ArrayList<>();
        strList.add("10");
        strList.add("100");
        printList(strList);
    }
}
```

Метод `printList()` принимает список, для которого в сигнатуре использована маска:

`static void printList(List<?> list) `

Этот метод работает для списков с различными типами данных (в примере Integer и String).

Однако вот это не скомпилируется:

```java
List<?> intList = new ArrayList<Integer>();
intList.add(new Integer(10));
/* intList.add(new Float(10.0f)); даже с закомментированной последней строкой не скомпилируется */
```

Почему не компилируется? При использовании маски мы сообщаем компилятору, чтобы он игнорировал информацию о типе,
т.е. `<?>` - **неизвестный тип**. При каждой попытке передачи аргументов дженерик-типа компилятор Java пытается определить
тип переданного аргумента. Однако теперь мы используем метод `add()` для вставки элемента в список.
При использовании маски мы не знаем, какого типа аргумент может быть передан. Тут вновь видна возможность ошибки, т.к.
если бы добавление было возможно, то мы могли бы попытаться вставить в наш список, предназначенный для чисел, строковое значение.
Во избежание этой проблемы, компилятор не позволяет вызывать методы, которые изменяют объект. Поскольку метод `add()` изменяет объект,
мы получаем ошибку. Тем не менее есть возможность получить доступ к информации, хранящейся в объекте,
с использованием маски, как это было показано выше.

Допустим нужно так объявить эту переменную, чтобы она хранила только списки чисел:

`List<? extends Number> numList = new ArrayList<Integer>();`

Тут видно, как маске задаётся ограничение – теперь `numList` предназначен для списка с ограниченным количеством типов.
*Double* как и *Integer* наследуется от *Number*, поэтому код приведённый ниже скомпилируется.

```java
List<? extends Number> numList = new ArrayList<Integer>();
numList = new ArrayList<Double>();
```

**То, что было описано выше называется ограниченными масками (Bounded wildcards)**.

Аналогично ключевому слову extends в подобного рода выражениях может использоваться ключевое
слово *super* - `<? super Integer>`. Выражение `<? super X>` означает, что вы можете использовать любой базовый тип
*(класс или интерфейс)* типа *Х*, а также и сам тип *Х*.

*Примечания:*

- в объявлении класса `?` - нельзя использовать, можно только - `Т`

  `class MyClass<T extends BaseClass>{ }` // ? - extends.. нельзя

- в возвращаемом типе метода так же не используется `?`, только `Т`

  ```java
  public static <T extends Number> double sum(ArrayList<T> numbers){ // ? extends Number - нельзя
    ...
  }
  ```

- списки инициализации не могут быть использованы для инициализации параметризованных массивов - `private <T> arr[] = {1, 2, 3, 4, 5}; // ошибка`

## 30. Интерфейсы Comparator и Comparable.

**Интерфейс java.lang.Comparable**

*Interface Comparable* задает свойство сравнения объекту реализующему его, т.е делает объект сравнимым (по правилам разработчика).
В интерфейсе *Comparable* объявлен всего один метод `compareTo(Object obj)`, предназначенный для реализации упорядочивания объектов класса.
Его удобно использовать при сортировке упорядоченных списков *(java.util.List)* или массивов объектов. Данный метод сравнивает вызываемый объект с `obj`.

`compareTo()` возвращает *int* со следующими значениями:

- 0, если значения равны
- -1, если вызываемый объект меньше параметра
- 1, если вызываемый объект больше параметра

Метод может выбросить исключение *ClassCastException*, если типы объектов не совместимы при сравнении.

*Классы Byte, Short, Integer, Long, Double, Float, Character, Boolean, String уже реализуют интерфейс Comparable.*

*Пример сортировки объектов User по одному полю - id:*

```java
public class User implements Comparable {

    public int id;
    public String name;

    public Student(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public int compareTo(Object obj) {

        User tmpUser = (User) obj;

        if (this.id < tmpUser.id) {
            return -1;
        } else if (this.id > tmpUser.id)
        {
            return 1;
        }
            return 0;
    }
}
```

*Пример сортировки объектов User по name, id:*

```java
public class User implements Comparable {

    public int id;
    public String name;

    public Student(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public int compareTo(Object obj) {

        User tmpUser = (User) obj;

        int result = this.name.compareTo(tmpUser.name); // в классе String метод compareTo уже реализован

        if (result != 0)
            return result; // возвращает -1 или 1 после сравнения двух значений

        // в случае если result = 0, т.е значения были одинаковыми, выполняем сравнение по id

        result = this.id - tmpUser.id;
        if (result != 0) {
            return (int) result / Math.abs(result);
        }
        return 0;
    }
}
```

После этого объекты класса `User` могут быть отсортированы при помощи

- `java.util.Collections.sort(List)`
- `Arrays.sort(Object[])`

*Объекты, которые используют класс *Comparable* могут быть использоване в `TreeMap` и `TreeSet`.*

**Интерфейс java.lang.Comparator**

При использование интерфейса *Comparator* логика сравнения находится *вне сравниваемых объектов*. В случае одновременного использования
*Comparable* и *Comparator* последний имеет приоритет.

Интерфейс *Comparator* содержит два метода:

- `compare(Object obj1, Object obj2)`
- `equals(Object obj)`

Метод `compare()` так же как и метод `compareTo`  возвращает `0, -1, 1`.
Метод может выбросить исключение *ClassCastException*,
если типы объектов не совместимы при сравнении.

Метод `equals()` сравнивает компараторы объектов и очень редко переопределяется.

*Сортировка производится при помощи*

- `Arrays.sort(T[] arg1, Comparator<? super T> arg2);`
- `Collections.sort(List<T> arg1, Comparator<? super T> arg2);`

Оба метода в качестве второго аргумента принимают компаратор.

*Пример использования Comparator:*

```java
class Product {

    private String name;
    private double price;
    private int quantity;

    public Product(String name, double price, int quantity) {

        this.name = name;
        this.price = price;
        this.quantity = quantity;

    }

    // getters & setters

}
```

*Создадим копаратор для сортировки по name*

```java
class SortedByName implements Comparator<Product> {

    public int compare(Product obj1, Product obj2) {

         String str1 = obj1.getName();
         String str2 = obj2.getName();

         return str1.compareTo(str2);
    }

}
```

*А так же сортировка по price*

```java
class SortedByPrice implements Comparator<Product> {

    public int compare(Product obj1, Product obj2) {

         double price1 = obj1.getPrice();
         double price2 = obj2.getPrice();

         if (price1 > price2)
            return 1;
         else if (price1 < price2)
            return -1;
         else
            return 0;
    }

}
*Пример использования:*

```java
public class Example {

    public static void main(String[] args) {
        Product[] products = new Product[3];

        // заполним объект Product содержимым
        products[0] = new Product("Milk", 7.56, 56);
        products[1] = new Product("Cofee", 17.00, 32);
        products[2] = new Product("Tea", 12.50, 0);

        // выведем данные без сортировки
        System.out.println("Unsorted:");
        for(Product product : products) {
            System.out.println("Name: " + product.getName() + " price: " + product.getPrice() + " quantity: " + product.getQuantity());
        }

        // отсортируем и выведем данные по цене
        Arrays.sort(products, new SortedByPrice());

        System.out.println("Sorted by price:");
        for(Product product : products) {
            System.out.println("Name: " + product.getName() + " price: " + product.getPrice() + " quantity: " + product.getQuantity());
        }

        // отсортируем и выведем данные по названию
        Arrays.sort(products, new SortedByName());

        System.out.println("Sorted by name:");
        for(Product product : products) {
            System.out.println("Name: " + product.getName() + " price: " + product.getPrice() + " quantity: " + product.getQuantity());
        }
    }

}
```

*Результат выполнения*

```java
Unsorted:
Name: Milk price: 7.56 quantity: 56
Name: Coffee price: 17.0 quantity: 32
Name: Tea price: 12.5 quantity: 0

Sorted by price:
Name: Milk price: 7.56 quantity: 56
Name: Tea price: 12.5 quantity: 0
Name: Coffee price: 17.0 quantity: 32

Sorted by name:
Name: Coffee price: 17.0 quantity: 32
Name: Milk price: 7.56 quantity: 56
Name: Tea price: 12.5 quantity: 0
```

## 31. Интерфейс Cloneable.

Метод `clone()` объявлен в классе *Object* с сигнатурой *native*, чтобы обеспечить доступ к стандартному механизму
**"поверхностного копирования"** объектов *(копируются значения всех полей, включая ссылки на сторонние объекты)*.

Интерфейс *Cloneable* является маркерным. Он нужен только для обозначения самого факта,
что данный объект готов к клонированию. Вызов переопределённого метода `clone()` у не
*Cloneable* объекта вызовет выбрасывание *CloneNotSupportedException* (это описано в объявлении метода).

Сам класс *Object* не является *Cloneable*, т.к. он является корневым классом в иерархии и это привело бы к тому,
что все классы являются по умолчанию *Cloneable*.

Для реализации **"глубокого клонирования"** (когда вместо копирования ссылок на содержащиеся объекты создаются новые экземпляры)
необходимо самим описать весь алгоритм действий в переопределённом методе `clone()`.

## 32. Сериализация.

Сериализация объектов - это процесс сохранения состояния объектов в виде последовательности байтов,
а также процесс восстановления в дальнейшем из этих байтов "живых" объектов.
*Java Serialization API* предоставляет разработчикам Java стандартный механизм управления сериализацией объектов.

Для сериализации объекта это объект должен быть отмечен как сериализуемый.
Это осуществляется путем реализации объектом *маркерного интерфейса* **java.io.Serializable**, что является для API знаком того,
что объект может быть разложен на байты, а затем вновь восстановлен.

*Пример сериализуемого класса:*

```java
public class PersistentTime implements Serializable {

    private Date time;

    public PersistentTime() {
    time = Calendar.getInstance().getTime();
    }

    public Date getTime() {
        return time;
    }

}
```

*Первое правило сериализации*

**Сохраняемый объект должен реализовать интерфейс Serializable или унаследовать эту реализацию от вышестоящего по иерархии объекта.**

Следующим шагом является сохранение объекта.

```java
public class FlattenTime {
    public static void main(String [] args) {

        String filename = "time.txt";
        PersistentTime time = new PersistentTime();
        FileOutputStream fos = null;
        ObjectOutputStream out = null;

        try {
            fos = new FileOutputStream(filename);
            out = new ObjectOutputStream(fos);
            out.writeObject(time); // запускается механизм сериализации и объект разлагается на байты (в данном случае в файл).
            out.close();
        }
            catch(IOException ex) {
            ex.printStackTrace();
        }
    }
}
```

*Пример десериализации объекта:*

```java
public class InflateTime {
    public static void main(String [] args) {

        String filename = "time.ser";
        PersistentTime time = null;
        FileInputStream fis = null;
        ObjectInputStream in = null;

        try {
            fis = new FileInputStream(filename);
            in = new ObjectInputStream(fis);
            time = (PersistentTime)in.readObject(); // происходит десериализация объекта
            in.close();
        }
        catch(IOException ex) {
            ex.printStackTrace();
        }
        catch(ClassNotFoundException ex) {
            ex.printStackTrace();
        }

    }
}
```

Необходио отмечать как *transient* все поля, которые либо не могут быть сериализованы, либо те, которые вы не хотите сериализовать.
Сериализация не заботится о модификаторах доступа, таких как *private*. Все поля рассматриваются как части
состояния сохраняемого объекта, предназначенные для сохранения.

**Сохраняемый объект должен пометить все свои несериализуемые поля как transient.**



## 33. Перечисления.

В простейшей форме перечисление - это список именованных констант.
Но в Java перечисления имеют более сложный функционал, чем в других языках программирования.
*Они могут иметь конструкторы, методы и переменные экземпляра и наследовать интерфейс.*

*Пример:*

`enum Season { WINTER, SPRING, SUMMER, AUTUMN }`

Объявляя *enum*, неявно создается класс, производный от **java.lang.Enum**.
Условно конструкция `enum Season { ... }` эквивалентна `class Season extends java.lang.Enum { ... }.`
И хотя явным образом наследоваться от *java.lang.Enum* компилятор не позволит, все же в том, что *enum* наследуется,
можно убедиться с помощью *reflection*:

`System.out.println(Season.class.getSuperclass()); // результат - class java.lang.Enum`

Собственно наследование автоматически выполняет компилятор Java.

Идентификаторы в фигурных скобках называются константами перечисления.
Каждый из них явно объявлен как открытый статический финальный член класса *Season*.
Объявив перечисление, можно создавать переменные этого типа. Но делать это нужно без оператора *new*, а в упрощенном виде.

```java
Season season; // объявление переменной season типа Season
Season season = Season.WINTER; // присвоим значение
```

Во время присваивания должен указываться и тип *Season*.

Статическая доступность элементов перечисления позволяет выполнять сравнение с
помощью оператора сравнения ссылок `==`.

*Пример:*

```java
Season season = Season.SUMMER;
if (season == Season.AUTUMN)
    season = Season.WINTER;
```

**Название и порядковый номер элемента enum**

Как было сказано ранее, любой *enum-класс* наследует *java.lang.Enum*, который содержит ряд методов полезных для всех перечислений.

*Пример:*

```java
Season season = Season.WINTER;
System.out.println("season.name()=" + season.name() + " season.toString()=" +
                season.toString() + " season.ordinal()=" + season.ordinal());
```

*Результат:*

`season.name()=WINTER season.toString()=WINTER season.ordinal()=0`

Здесь показано использования методов `name()`, `toString()` и `ordinal()`.
Следует обратить внимание, что данные методы enum-класс наследует из класса *java.lang.Enum*

**Получение елемента enum по строковому представлению его имени**

Довольно часто возникает задача получить элемент *enum* по его строковому представлению.
Для этих целей в каждом enum-классе компилятор автоматически создает специальный статический метод,
который возвращает элемент перечисления *EnumClass* с названием, равным name.

`public static EnumClass valueOf(String name)`,

*Пример:*

```java
String name = "WINTER";
Season season = Season.valueOf(name);
```

В результате выполнения кода переменная *season* будет равна `Season.WINTER`.
Следует обратить внимание, что если элемент не будет найден, то **будет выброшен IllegalArgumentException, а в случае,
если `name` равен null - NullPointerException**.

**Получение всех элементов перечисления**

Иногда необходимо получить список всех элементов enum-класса во время выполнения.
Для этих целей в каждом enum-классе компилятор создает метод:

`public static EnumClass[] values()`

*Пример:*

`System.out.println(Arrays.toString(Season.values())); // [WINTER, SPRING, SUMMER, AUTUMN]`

**Ни метод valueOf(), ни метод values() не определен в классе java.lang.Enum.**
*Вместо этого они автоматически добавляются компилятором на этапе компиляции enum-класса.*

## 34. Рефлексия.

Рефлексия - это механизм исследования данных о программе во время её выполнения. Рефлексия позволяет исследовать информацию
о полях, методах и конструкторах классов. Можно также выполнять операции над полями и методами которые исследуются.
Рефлексия в Java осуществляется с помощью **Java Reflection API**. Этот интерфейс API состоит из классов
пакетов `java.lang` и `java.lang.reflect`. Все классы для работы с *reflection* расположены в пакете `java.lang.reflect`:

- `Method`
- `Constructor`
- `Array`
- `Field`
- `Modifier`

*С помощью интерфейса *Java Reflection API* можно делать следующее:*

- Определить класс объекта.
- Получить информацию о модификаторах класса, полях, методах, конструкторах и суперклассах.
- Выяснить, какие константы и методы принадлежат интерфейсу.
- Создать экземпляр класса, имя которого неизвестно до момента выполнения программы.
- Получить и установить значение свойства объекта.
- Вызвать метод объекта.
- Создать новый массив, размер и тип компонентов которого неизвестны до момента выполнения программ.

Самое простое, что обычно делается в динамическом программировании, - это получают объект типа `java.lang.Class`.
Если есть экземпляр объекта *Class*, то можно получить всевозможную информацию об этом классе и даже осуществлять операции над ним.

```java
MyClass a = new MyClass();
Class aclass = a.getClass();
```

Метод `getClass()` часто полезен тогда, когда есть экземпляр объекта, но не известно какого класса этот экземпляр.

Если есть класс, для которого в момент компиляции известен тип, то получить экземпляр класса ещё проще.

```java
Class aclass = MyClass.class;
Class iclass = Integer.class;
```

Если имя класса не известно в момент компиляции, но становится известным во время выполнения программы,
можно использовать метод `forName()`, чтобы получить объект *Class*.

`Class c = Class.forName("com.mysql.jdbc.Driver");`

**Получение имени класса**

```java
Class c = myObject.getClass();
String s = c.getName();
```
Объект типа *String*, возвращаемый методом `getName()`, будет содержать полностью уточненное имя класса,
т.е. если типом объекта *myObject* будет *Integer*, то результат будет вида `java.lang.Integer`.

**Исследование модификаторов класса**

```java
Class c =  obj.getClass();
int mods = c.getModifiers();

if (Modifier.isPublic(mods))
    System.out.println("public")

if (Modifier.isAbstract(mods))
    System.out.println("abstract")

if (Modifier.isFinal(mods))
    System.out.println("final")
```

Чтобы узнать, какие модификаторы были применены к заданному классу, сначала нужно с помощью метода `getClass` получить
объект типа *Class*, представляющий данный класс. Затем нужно вызвать метод `getModifiers()`, чтобы определить значение типа *int*,
биты которого представляют модификаторы класса. После этого можно использовать статические методы класса
`java.lang.reflect.Modifier`, чтобы определить, какие именно модификаторы были применены к классу.

**Нахождение суперклассов**

```java
Class c = myObj.getClass();
Class superclass = c.getSuperclass();
```

Можно также использовать метод `getSuperclass()`, чтобы получить объект типа *Class*, представляющий суперкласс рефлексированного класса.
Нужно не забывать учитывать, что в Java отсутствует множественное наследование и класс `java.lang.Object` является базовым
классом для всех классов, вследствие чего если у класса нет родителя то метод `getSuperclass` вернет *null*.

**Определение интерфейсов, реализуемых классом**

```java
Class c =  LinkedList.class;
Class[] interfaces = c.getInterfaces();

for(Class cInterface : interfaces) {
    System.out.println(cInterface.getName());
}
```

С помощью рефлексии можно также определить, какие интерфейсы реализованы в заданном классе.
Метод `getInterfaces()` вернет массив объектов типа *Class*. Каждый объект в массиве представляет один интерфейс, реализованный в заданном классе.

**Исследование, получение и установка значений полей класса.**

```java
Class c = obj.getClass();
Field[] publicFields = c.getFields();

for (Field field : publicFields) {
    System.out.println("Имя: " + field.getName());
    System.out.println("Тип: " + field.getType().getName());
}
```

Чтобы исследовать поля принадлежащие классу, можно воспользоваться методом `getFields()`.
Метод `getFields()` возвращает массив объектов типа `java.lang.reflect.Field`, соответствующих всем *public* полям объекта.
Эти *public* поля необязательно должны содержаться непосредственно внутри класса, они также могут
содержатся в *суперклассе, интерфейсе или интерфейсе представляющем собой расширение интерфейса, реализованного классом*.

С помощью класса *Field* можно получить имя поля, тип и модификаторы. Если известно имя поля, то можно получить о
нем информацию с помощью метода `getField(String name)`.

```java
Class c = obj.getClass();
Field nameField = c.getField("name");
```

Методы `getField()` и `getFields()` возвращают только *public* члены класса.
Если требуется получить все поля некоторого класса нужно использовать методы `getDeclaredField()` и `getDeclaredFields()`.
Эти методы работают точно также как их аналоги `getField()` и `getFields()`, за исключением того, что они возвращают все поля,
включая *private* и *protected*. Чтобы получить значение поля, нужно сначала получить для этого поля объект типа *Field*,
затем использовать метод *get()*. Метод принимает входным параметром ссылку на объект класса.

```java
Class c = obj.getClass();
Field field = c.getField("name");
String nameValue = (String) field.get(obj)
```

Так же у класса *Field* имеются специализированные методы для получения значений примитивных типов: `getInt()`, `getFloat()`, `getByte()` и др.

Для установки значения поля, используется метод `set()`.

```java
Class c = obj.getClass();
Field field = c.getField("name");
field.set(obj, "New name");
```

Для примитивных типов имеются методы `setInt()`, `setFloat()`, `setByte()` и др.

**Исследование конструкторов класса**

```java
Class c = obj.getClass();
Constructor[] constructors = c.getConstructors();
for (Constructor constructor : constructors) {
    Class[] paramTypes = constructor.getParameterTypes();
    for (Class paramType : paramTypes) {
        System.out.print(paramType.getName() + " ");
    }
    System.out.println();
}
```

Чтобы получить информацию о *public* конструкторах класса, нужно использовать метод `getConstructors()`.
Этот метод возвращает массив объектов типа `java.lang.reflect.Constructor`. С помощью объекта класса
*Constructor* можно затем получить имя конструктора, модификаторы, типы параметров и генерируемые исключения.
Можно также получить по отдельному открытому конструктору, если известны типы его параметров.

Методы `getConstructor()` и `getConstructors()` возвращают только открытые конструкторы.
Если требуется получить все конструкторы класса, включая закрытые, то  можно использовать методы `getDeclaredConstructor()` и
`getDeclaredConstructors()` эти методы работают точно также, как их аналоги `getConstructor()` и `getConstructors()`.

**Исследование информации о методе, вызов метода.**

```java
Class c = obj.getClass();
Method[] methods = c.getMethods();

for (Method method : methods) {
    System.out.println("Имя: " + method.getName());
    System.out.println("Возвращаемый тип: " + method.getReturnType().getName());

    Class[] paramTypes = method.getParameterTypes();
    System.out.print("Типы параметров: ");

    for (Class paramType : paramTypes) {
        System.out.print(" " + paramType.getName());
    }

}
```

Чтобы получить информацию об открытых методах класса, нужно вызвать метод `getMethods()` для объекта *Class*.
Этот метод возвращает массив объектов типа `java.lang.reflect.Method`. Затем с помощью объекта *Method* можно получить имя метода,
тип возвращаемого им значения, типы параметров, модификаторы и генерируемые исключения.

Методы `getMethod()` и `getMethods()` возвращают только открытые методы, для того чтобы получить все методы класса не
зависимо от типа доступа, нужно воспользоватся методами `getDeclaredMethod()` и `getDeclaredMethods()`, которые работают
точно также как и их аналоги (`getMethod()` и `getMethods()`).

**Загрузка и динамическое создание экземпляра класса**

```java
Class c = Class.forName("Test");
Object obj = c.newInstance();
Test test = (Test) obj;
```

С помощью методов `Class.forName()` и `newInstance()` объекта *Class* можно динамически загружать и создавать экземпляры класса
в случае, когда имя класса неизвестно до момента выполнения программы. В приведенном коде мы загружаем класс с помощью
метода `Class.forName()`, передавая имя этого класса. В результате возвращается объект типа *Class*. Затем мы вызываем метод
`newInstance()` для объекта типа *Class*, чтобы создать экземпляры объекта исходного класса. Метод `newInstance()` возвращает
объет обобщенного типа *Object*, поэтому в последней строке происходит приведение возвращаемого объекта к тому типу, который нужен.

*Пример модификации private полей:*

```java
import java.lang.reflect.Field;

class WithPrivateFinalField {
    private int i = 1;
    private final String s = "String S";
    private String s2 = "String S2";

    public String toString() {
        return "i = " + i + ", " + s + ", " + s2;
    }
}

public class ModifyngPrivateFields {

    public static void main(String[] args) throws Exception {

        WithPrivateFinalField pf = new WithPrivateFinalField();

        Field f = pf.getClass().getDeclaredField("i");
        f.setAccessible(true);
        f.setInt(pf, 47);
        System.out.println(pf);

        f = pf.getClass().getDeclaredField("s");
        f.setAccessible(true);
        f.set(pf, "MODIFY S");
        System.out.println(pf);


        f = pf.getClass().getDeclaredField("s2");
        f.setAccessible(true);
        f.set(pf, "MODIFY S2");
        System.out.println(pf);

    }
}
```

Из приведённого кода видно, что *private* поля можно изменять. Для этого требуется получить объект типа
`Field` с помощью метода `getDeclaredField()`, вызвать метод `setAccessible(true)` и с помощью метода
`set()` устанавливаем значение поля.

Важно знать, что поле *final* при выполнении данной процедуры не выдаёт предупреждений, но значение останется прежним,
т.е. *final* поля остаются неизменные.

## 35. Загрузка классов.

Классы загружаются в JVM в порядке, в котором идут ссылки на них (по имени) в уже работающих в JVM классах.

*Как загружается самый первый класс?*

Он загружается с помощью `public static void main()` метода, объявленного в этом классе.
Дальнейшая загрузка классов производится классами, которые уже загружены и работают в JVM. *Class loader* создает пространство имен (*namespace*).

Все JVM включают хотя бы один встроенный загрузчик классов, который называют *первичным или первоначальным загрузчиком (bootstrap)*.
В JVM реализованы хуки (hooks), которые позволяют использовать определяемые пользователем загрузчики классов вместо первичного загрузчика.
Как правило в JVM есть три загрузчика классов: первичный загрузчик (*bootstrap*), загрузчик расширений
(*extensions class loader*) и системный загрузчик (*system class loader*).

- Первичный загрузчик загружает внутренние классы из JDK, java.* пакеты, rt.jar и i18n.jar.
- Загрузчик расширений загружает .jar файлы из директории extensions в JDK.
- Системный загрузчик загружает классы из системного *classpath*.

Статическая загрузка происходит при использовании java оператора *new*:

`Flower flower = new Flower();`

Если на класс существует ссылка оператором *new*, а система выполнения не может найти этот класс, бросается исключение *NoClassDefFoundException*.

Динамическая загрузка - это техника программного вызова функций загрузчика классов во время выполнения:

`Class.forName(String className); // статический метод, который возвращает объект типа Class`

Объект типа *Class* ассоциирован с указанным именем класса. Строка *className* может быть передана динамически во время выполнения.
В отличие от статической загрузки, во время динамической загрузки будет принято решение, какой класс загружать:

Когда приложение пытается загрузить класс по имени, используя следующие методы:

- Class.forName(..),
- ClassLoader.findSystemClass(..),
- ClassLoader.loadClass(..), выбрасывается исключение ClassNotFoundException.

## 36. Типы ссылок.

Всего существует 4 типа ссылок на объекты:

- *strong reference*
- *weak reference*
- *soft reference*
- *phantom reference*

**Strong references**

В Java объекты, создаваемые через оператор *new* создаются по *strong* ссылке. Сборщик мусора (garbage collector) уничтожает
такие объекты только тогда, когда на них больше не остается сильных (strong) ссылок.

**Weak references**

Слабые ссылки представлены классом `java.lang.ref.WeakReference`.

Слабую ссылку можно определить следующим образом:

```java
Counter counter = new Counter(); // strong reference
WeakReference<Counter> weakCounter = new WeakReference<Counter>(counter); // weak reference
counter = null; // now Counter object is eligible for garbage collection
```

После присвоения *strong* ссылке `counter` значение *null*, тот объект, что создан в первой строке, становится доступным
для удаления сборщиком мусора. Созданная *Weak* ссылка `weakCounter` не может предотвратить удаление
сборщиком мусора объекта *Counter*, даже если имеется достаточное количество свободной памяти.

*С другой стороны если бы это была *Soft* ссылка, объект типа *Counter* не был бы удален до тех пор пока *JVM* не нуждалась бы в памяти.*

**Soft references**

Объекты, созданные через *SoftReference*, будут собраны в случае, если *JVM* требует память. То есть имеется гарантия,
что все *soft reference* объекты будут собраны перед тем, как *JVM* выбросит *OutOfMemoryError*.

```java
Counter prime = new Counter();  // prime holds a strong reference
SoftReference<Counter> soft = new SoftReference<Counter>(prime) ; // soft reference variable has SoftReference to Counter Object
prime = null;  // now Counter object is eligible for garbage collection but only be collected when JVM absolutely needs memory
```

После обнуления *strong* ссылки (в 3-ей строке) на объект *Counter* останется только 1 мягкая ссылка, которая не сможет предотвратить
удаление этого объекта сборщиком мусора, но в отличие от *weak* ссылки сможет отложить этот процесс до тех пор
пока не появится памяти.

*SoftReference* часто используется для кешей, потребляющих большое количество памяти.

**Phantom references**

*Phantom* ссылки представлены классом `java.lang.ref.PhantomReference`. Объект на который указывают только *phantom* ссылки
может быть удален сборщиком в любой момент. *Phantom* ссылка создается точно так же как *weak* или *soft*.

```java
DigitalCounter digit = new DigitalCounter(); // digit reference variable has strong reference
PhantomReference<DigitalCounter> phantom = new PhantomReference<DigitalCounter>(digit); // phantom reference
digit = null;
```

## 37. Как работает Garbage Collector.

## 38. Основы управления памятью в Java.

## 39. Ключевое слово native.

**Java Native Interface (JNI)** — стандартный механизм для запуска кода, под управлением виртуальной машины Java (JVM),
который написан на языках С/С++ или Ассемблера, и скомпонован в виде динамических библиотек.
Это даёт возможность вызова функции С/С++ из программы на Java, и наоборот.

Модификатор *native* говорит о том, что метод реализован в платформо-зависимом коде, часто на языке С.

Этот модификатор может быть применен только к методам, но не классам и переменным.

Тело нативного метода должно заканчиваться на *;* как в абстрактных методах, говоря о том, что реализация опущена.

Методы, помеченные *native*, можно переопределять обычными методами в подклассах (к примеру в классе *Object* много native методов).
