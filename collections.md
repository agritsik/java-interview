1. Введение в Java Collections Framework.
2. Collection Interface.
    2.1 List Interface и реализации.
    2.2 Set Interface и реализации.
    2.3 Queue Interface и реализации.
    2.4 Deque Interface и реализации.
3. Map Interface.
    3.1 Map Interface реализации.
4. Итератор
5. Другие общие вопросы.

### 1. Введение в Java Collections Framework.

**Java Collection Framework** — иерархия интерфейсов и их реализаций, которая является частью JDK и позволяет
разработчику пользоваться большим количесвом структур данных из «коробки».

Для хранения наборов данных в Java предназначены массивы. Однако их не всегда удобно использовать, прежде всего потому,
что они имеют фиксированную длину. Эту проблему в Java решают коллекции *(контейнеры)*. Однако суть не только в гибких по размеру
наборах объектов, но в и том, что классы коллекций реализуют различные алгоритмы и структуры данных, например,
такие как стек, очередь, дерево и ряд других.

В библиотеке коллекций Java существует два базовых интерфейса **Collection** и **Map**.
Эти интерфейсы разделяют все коллекции, входящие во фреймворк на две части по типу хранения данных:
*простые последовательные наборы элементов и наборы пар «ключ — значение»*.

- **Collection** - коллекция содержит набор объектов (элементов). Здесь определены основные методы для манипуляции с данными,
такие как вставка (`add()`, `addAll()`), удаление (`remove()`, `removeAll()`, `clear()`), поиск (`contains()`).
Так же в версии Java 8 было добавлено несколько новых метода для работы с лямбдами (такие как `stream()`, `parallelStream()`,
`removeIf(Predicate<? super E> filter)` и др.). Важно также отметить, что эти медоды были реализованы непосредственно
в интерфейсе как *default-медоды*.

- **Map** -  описывает коллекцию, состоящую из пар "ключ — значение". У каждого ключа только одно значение.
Такую коллекцию часто называют еще словарем (dictionary) или ассоциативным массивом (associative array).
*Никак НЕ относится к интерфейсу Collection и является самостоятельным.* в версии Java 8 появились дополнительные методы
для работы с лямбдами, а также методы, которые зачастую реализовались в логике приложения
(`getOrDefault(Object key, V defaultValue)`, `putIfAbsent(K key, V value)`).

*Иерархия интерфейсов Java Collections Framework*

![Java Collections Hierarchy](https://github.com/krasilnikovdmtr/java-interview/blob/master/images/Core%20Interface%20Hierarchy%20-%20New%20Page.png)

Все интерфейсы являются типизированными, к примеру:

`public interface Collection<E>...`

*Интерфейс определяет «что делает коллекция», а конкретная реализация — «как коллекция делает то, что определяет интерфейс»*

### 2. Collection Interface.

`java.util.Collection<E>` является одним из двух базовых интерфейсов фреймворка *Java Collections*.

```java
public interface Collection<E> extends Iterable<E>{
    // базовые методы
}
```

В интерфейсе `java.util.Collection<E>` определены основные методы для манипуляции с данными, такие как вставка
(`add(), addAll()`), удаление (`remove(), removeAll(), clear()`), поиск (`contains()`) и т.д.

![Java Collections Hierarchy](https://github.com/krasilnikovdmtr/java-interview/blob/master/images/Collection%20Interface%20-%20New%20Page.png?raw=true)

Интерфейс *Collection* реализует интерфейс *Iterable*, у которого есть только один метод:

`public abstract Iterator iterator()`

Интерфейс `java.lang.Iterable<T>` указывает на то что коллекция, реализующая его, может формировать объект-итератор,
реализующий интерфейс `java.util.Iterator<E>`, а значит может быть использована в конструкции *for* (в виде for-each).

### 2.1 List Interface и реализации.

`public interface List<E> extends Collection<E> { ... }`

*List* - упорядоченная (но неотсортированная) коллекция, иногда называемая списком или последовательностью.
Список может содержать повторяющиеся, а так же null элементы. Элементы списка пронумерованы, начиная с нуля и к
конкретному элементу можно обратиться по целочисленному индексу.

![List Interface](https://github.com/krasilnikovdmtr/java-interview/blob/master/images/List%20Interface%20-%20New%20Page.png?raw=true)

Интерфейс *List* является наследником интерфейса *Collection*, поэтому содержит все его методы и добавляет к ним несколько своих:

- `add(int index, Object item)` – вставляет элемент item в позицию index, при этом список	увеличивается
(все элементы, начиная с позиции index, увеличивают свой индекс	на 1), или заменяет элемент, если под таким индексом уже существует;
- `get(int index)` – возвращает объект, находящийся в позиции index;
- `indexOf(Object obj)` – возвращает индекс первого появления элемента obj в списке;
- `lastIndexOf(Object obj)` – возвращает индекс последнего появления элемента obj в списке;
- `add(int index, Object item)` – заменяет элемент, находящийся в позиции index объектом item;
- `subList(int from, int to)` – возвращает новый список, представляющий собой часть данного (начиная с позиции from до позиции to-1 включительно).

Два объекта типа List одинаковы (метод `equals()` возвращает *true*) только в том случае,
когда они содержат одинаковые элементы в одном и том же порядке.

Существуют следующие реализации интерфейса List:

- ArrayList
- LinkedList
- Vector
- Stack.

*Конкретный выбор реализации списка сказывается на эффективности работы с объектами списка.*

**ArrayList**

`public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, java.io.Serializable { ... }`

Класс `java.lang.ArrayList` представляет обобщенную коллекцию, которая наследует свою функциональность от класса *AbstractList* и реализует интерфейс *List*.

*ArrayList* имеет следующие конструкторы:

- `ArrayList()` - создает пустой список, с длиной массива по умолчанию 10 элементов (все элементы хранят null)
- `ArrayList(Collection <? extends E> col)` - создает список, в который добавляются все элементы коллекции *col*
- `ArrayList (int capacity)` - создает список, который имеет начальную емкость - *capacity*

*ArrayList* инкапсулирует в себе обычный массив, длина которого автоматически увеличивается при добавлении новых элементов.
Так как *ArrayList* использует массив, то время доступа к элементу по индексу минимально (в отличии от *LinkedList*).
При удалении произвольного элемента из списка, все элементы находящиеся «правее» смещаются на одну ячейку влево,
при этом реальный размер массива (его емкость, capacity) не изменяется, до явного вызова метода `trimToSize()`.

**Как устроен ArrayList**

Как было сказано, *ArrayList* для хранения данных использует обычный массив. В классе *ArrayList* есть поле, которое
представляет массив типа `Object`.

`transient Object[] elementData;`

При создании объекта *ArrayList* массив будет проинициализирован. При использовании конструктора по умолчанию, будет
выполнено следующее (в упрощенном виде):

```java
public ArrayList() {
    this.elementData = new Object[10];
}
```

При использовании конструктора с параметром *capacity*:

```java

public ArrayList(int initialCapacity) {
    if (initialCapacity > 0) {
        this.elementData = new Object[initialCapacity];
    }

    ...

}
```

Считается, что *ArrayList* имеет преимущество в использовании над массивами, т.к основан на динамическом массиве, который
автоматически увеличивается свой размер при добавление элементов.

*На самом деле никакое динамическое увеличение размера не происходит, а просто создается новый массив, в который копируется
старый массив и добавляемый элемент.*

Для добавление элементов в *ArrayList* используется метод `add()`:

```java
public boolean add(E e) {
    ensureCapacityInternal(size + 1);
    elementData[size++] = e;
    return true;
}
```

Перед тем как добавить элемент в массив, вызывается метод `ensureCapacityInternal()`, который проверяет текущее количество
элементов в массиве и размер массива. В случае если количество элементов плюс новый элемент будут превышать максимальный размер
массива, то будет создан новый массив размером:

`(size * 3) / 2 + 1 // в полтора раза больше предыдущего`

В него будут скопированы все элементы из старого массива + новый, добавляемый элемент.
Подобные перераспределения памяти уменьшают производительность. Поэтому если точно известно, что список не будет
содержать больше определенного количества элементов, то можно сразу же установить это количество в конструкторе.

*ArrayList* имеет ограничение на максимальное количество элементов.
Для индексаций элементов в *ArrayList* используется *int* тип. Поэтому в *ArrayList* помещается не более *Integer.MAX_VALUE - 8* элементов.

*Some VMs reserve some header words in an array. The maximum "safe" number would be 2 147 483 639 (Integer.MAX_VALUE - 8).
Attempts to allocate larger arrays may result in java.lang.OutOfMemoryError.*

**LinkedList**

`public class LinkedList<E> extends AbstractSequentialList<E> implements List<E>, Deque<E>, Cloneable, java.io.Serializable { ... }`

Класс `java.lang.LinkedList` — представляет собой классический двусвязный список.

*LinkedList* является противоположностью к *ArrayList* и не использует для хранения данных массив, а представляет собой
структуру двусвязного списка. Позволяет добавлять любые элементы в том числе и *null*. Доступ к произвольному элементу
осуществляется за линейное время - O(n), но доступ к первому и последнему элементу списка всегда осуществляется за константное время O(1).

![Java Collections Hierarchy](https://github.com/krasilnikovdmtr/java-interview/blob/master/images/Structure%20of%20linkedlist%20-%20New%20Page.png?raw=true)

*Cсылки постоянно хранятся на первый и последний элемент,
так что добавление элемента в конец списка вовсе не значит, что придется перебирать весь список в поисках
последнего элемента (об этом подробнее дальше).*

**Как устроен LinkedList**

Как известно, *LinkedList* реализует интерфейсы *List* и *Deque*, используя двусвязный список. Внутри класса *LinkedList*
есть статические вложенный класс *Node*, который определяет структуру "узла" двусвязного списка.

```java
private static class Node<E> {
    E item;
    Node<E> next;
    Node<E> prev;
    Node(Node<E> prev, E element, Node<E> next) {
        this.item = element;
        this.next = next;
        this.prev = prev;
    }
}
```

Для того, чтобы понять как работает *LinkedList* достаточно разобраться с тем, как элементы добавляются в список.

Есть три основных метода:

- `private void linkFirst(E e)` - добавляет элемент в начало списка
- `void linkLast(E e)` - добавляет элемент в конец списка
- `public void add(int index, E element)` - добавляет элемент по индексу

Так же важно знать, что в *LinkedList* *всегда* хранятся ссылки на первый и последний элемент списка:

```java
transient Node<E> first;
transient Node<E> last;
```

*Реализация метода `linkFirst()`*:

```java
private void linkFirst(E e) {
    final Node<E> f = first;
    final Node<E> newNode = new Node<>(null, e, f);
    first = newNode;
    if (f == null)
        last = newNode;
    else
        f.prev = newNode;
    size++;
    modCount++;
}
```

При добавлении самого первого элемента в список *first* и *last* будут указывать на этот элемент.
В случае, если список уже содержал элементы, то при добавлении нового элемента в начало списка происходит
замена ссылок и *first* уже будет указывать на новый добавленный элемент.

`final Node<E> f = first;` - сохраняем ссылку на элемент, который был первым до добавления<br/>
`final Node<E> newNode = new Node<>(null, e, f);` - создаем новый *Node* и указываем в качестве *next* ссылку на предыдущий
первый элемент<br/>
`first = newNode;` - *first* теперь указывает на новый добавленный элемент


```java
if (f == null)
        last = newNode; // выполняется в случае если список был пустой
else
        f.prev = newNode; // в случае если список содержал элементы, то f уже оказывается на второй позиции, и f.prev должен указывать на новый добавленный элемент
```

*Реализация метода `linkLast()`*:

```java
private void linkLast(E e) {
    final Node<E> l = last;
    final Node<E> newNode = new Node<>(l, e, null);
    last = newNode;
    if (l == null)
        first = newNode;
    else
        l.next = newNode;
    size++;
    modCount++;
}
```

Принцип работы такой же как и в предыдущем методе, только элемент добавляется в конец списка.
Метод `linkLast(E e)` используется при добавлении элементов через метод `add(E e)`.

Метод `add(int index, E element)` используется для добавления элемента по индексу.

```java
public void add(int index, E element) {
    checkPositionIndex(index); // проверяет index >= 0 && index <= size, в противном случае выбрасывает IndexOutOfBoundsException

    if (index == size)
        linkLast(element);
    else
        linkBefore(element, node(index)); // node(index) - возвращает объект Node из списка по указанной позиции
}

void linkBefore(E e, Node<E> succ) {
        final Node<E> pred = succ.prev;
        final Node<E> newNode = new Node<>(pred, e, succ);
        succ.prev = newNode;
        if (pred == null)
            first = newNode;
        else
            pred.next = newNode;
        size++;
        modCount++;
    }
```

**Сравнение скорости работы ArrayList и LinkedList**

<table>
    <thead>
        <tr>
            <th>Реализация</th>
            <th>Поиск</th>
            <th>Удаление</th>
            <th>Вставка</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>ArrayList</td>
            <td>O(1)</td>
            <td>O(n)</td>
            <td>O(n)</td>
        </tr>
        <tr>
            <td>LinkedList</td>
            <td>O(n)</td>
            <td>O(1)</td>
            <td>O(1)</td>
        </tr>
    <tbody>
</table>

*Поиск*

Т.к *ArrayList* хранит элементы в массиве, то доступ к элементу по индексу выполняется максимально быстро.
В *LinkedList* же необходио пройти через все элементы списка, чтобы найти нужный.

```java

// пример поиска по индексу в LinkedList

Node<E> x = first;
    for (int i = 0; i < index; i++)
        x = x.next;
return x;
```

*Удаление*

При удалении элементов из *LinkedList* достаточно лишь поменять ссылки у двух соседних элементов удаляемого элемента.
При удалении элементов из *ArrayList*, все элементы, которые находятся правее удаляемого элемента должны сдвинуться на одну
позицию левее.

*Вставка*

*ArrayList* выполняет вставку за O(n) в худшем случае. Причина такая же как и при удаление.
В *LinkedList* достаточно поменять ссылки у элементов.

*Отсюда следует, что LinkedList лучше применять когда часто происходит добавление и удаление элементов и когда ненужно
часто получать элемент из коллекции по индексу. ArrayList лучше использовать когда необходимо часто получать элементы из
коллекции, а добавлять редко; и не следует использовать когда коллекция часто изменяется*

**Vector**

`public class Vector<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, java.io.Serializable { ... }`

*Vector* — реализация динамического массива объектов. Позволяет хранить любые данные, включая *null* в качестве элемента.
*Vector* появился в *JDK версии Java 1.0*, но как и *Hashtable*, эту коллекцию не рекомендуется использовать, если не требуется
достижения потокобезопасности. Потому как в *Vector*, в отличии от других реализаций *List*, все операции с
данными являются синхронизированными. В качестве альтернативы часто применяется аналог — *ArrayList*.

**Stack**

`public class Stack<E> extends Vector<E> { ... }`

*Stack* — данная коллекция является расширением коллекции *Vector*. Была добавлена в *Java 1.0* как реализация стека *LIFO (last-in-first-out)*.
Является частично синхронизированной коллекцией (кроме метода добавления `push()`).
После добавления в *Java 1.6* интерфейса *Deque*, рекомендуется использовать именно
реализации этого интерфейса, например *ArrayDeque*.

*Vector и Stack являются устаревшими коллекциями в Java*

### 2.2 Set Interface и реализации.

`public interface Set<E> extends Collection<E> { ... }`

*Set* - коллекция, которая не может содержать одинаковых элементов, иногда называемая *множеством*.
Более формально, коллекция не может содержать пары элементов *e1* и *e2* таких, чтобы условие `e1.equals(e2)` было *true*
и не более одного *null* элемента.

![Java Collections Hierarchy](https://github.com/krasilnikovdmtr/java-interview/blob/master/images/Set%20Interface%20-%20New%20Page.png?raw=true)

Интерфейс *Set* реализует интерфейс *Collection* и в отличии от интерфейса *List* не дополняет никакими методами.
Разные реализации *Set* используют разный порядок хранения элементов.

Существуют следующие реализации интерфейса Set:

- HashSet
- TreeSet
- LinkedHashSet

**HashSet**

`public class HashSet<E> extends AbstractSet<E> implements Set<E>, Cloneable, Serializable { ... }`

*HashSet* инкапсулирует в себе объект *HashMap* (использует для хранения хэш-таблицу).
Ключ (хэш-код) используется *вместо индекса* для доступа к данным, что значительно ускоряет поиск определенного элемента.
Все элементы такого множества упорядочены посредством хэш-таблицы, в которой хранятся хэш-коды элементов.

*HashSet* имеет следующие конструкторы:

- `HashSet()` - создает пустое множество, с емкостью *capacity* - 16 и *loadFactor* - 0.75
- `HashSet(Collection <? extends E> col)` - создает множество, в которое добавляются все элементы коллекции *col*.
- `HashSet(int capacity)` - создает множество с указанной начальной емкостью - *capacity*
- `HashSet(int initialCapacity, float loadFactor)` - создает множество с указанной начальной емкостью - *capacity* и фактором загрузки - *loadFactor*

*loadFactor* — коэффициент загрузки, по умолчанию равен 0.75. Используется для определения предельного количества
элементов, при достижениее которого размер хэш-таблицы увеличиваетя вдвое. Если указать больше единицы, то увеличения
размера коллекции происходить не будет (точно так же в *HashMap*).

Рассчитывается по формуле *capacity x loadFactor*.

При использовании *HashSet* для хранения объектов пользовательских классов необходимо переопределить методы
`hashCode()` и `equals()`, иначе два логически-одинаковых объекта будут считаться разными, т.к при добавлении элемента
в коллекцию будет вызываться метод `hashCode()` класса *Object*, который скорее-всего вернет разный хэш-код для двух объектов.

**Как устроен HashSet**

Как было сказано выше, *HashSet* инкапсулирует в себе объект *HashMap*, а это значит, что вся работа с элементами происходит
по такой же схеме как и в *HashMap*.

При создании объекта *HashSet* каждый раз будет создаваться объект *HashMap*, это можно посмотреть в исходниках класса *HashSet*
(каждый из 4 конструкторов *HashSet* создает новый объект *HashMap<E,Object> map*). Объект *HashMap* используется для хранения,
получения, удаления элементов, которые мы помещаем в *HashSet*. О том как работает *HashMap* подробно описано в п.3.

Принципе в том, что *HashMap* хранит элементы по ключу и значению. И в качестве ключей будут использоваться
элементы множества *HashSet*. В качестве значения будет использоваться константа из класса *HashSet*:

```java
// Dummy value to associate with an Object in the backing Map
private static final Object PRESENT = new Object();
```

Если посмотреть как реализован метод `add()` в *HashSet*, то можно увидеть, что внутри вызывается метод `put()`
у объекта класса *HashMap*, который был создан в конструкторе.

```java
public boolean add(E e) {
    return map.put(e, PRESENT) == null;
}
```

Таким же образом (через объект *HashMap<E,Object> map*) работают и другие методы - `get()`, `remove()`, `contains()` и т.д.

Т.к *HashSet* хранит элементы в хеш-таблице, то он имеет наиболее высокую производительность,
но не гарантирует порядок элементов;

**TreeSet**

`public class TreeSet<E> extends AbstractSet<E> implements NavigableSet<E>, Cloneable, Serializable`

*TreeSet* - это коллекция, которая хранит свои элементы в виде упорядоченного по значениям бинарного дерева.
При добавлении объекта в дерево он сразу же размещается в необходимую позицию с учетом сортировки.
Сортировка происходит благодаря тому, что все добавляемые элементы реализуют интерфейсы *Comparator* и *Comparable*.
Обработка операций удаления и вставки объектов происходит медленнее, чем в хэш-множествах, но быстрее, чем в списках

*TreeSet* имеет следующие конструкторы:

- `TreeSet()` - создает пустое дерево, которое будет отсортировано по возрастанию, учитывая естественную сортировку элементов
- `TreeSet(Collection<? extends E> c)` - создает дерево из элементов коллекции *c*
- `TreeSet(Comparator<? super E> comparator)` - создает пустое дерево, которое будет отсортировано, согласно компоратору
- `TreeSet(SortedSet<E> s)` - создает дерево из элементов отсортированной коллекции *s*

Класс *TreeSet<>* содержит следующие основные методы:

- по извлечению первого и последнего (наименьшего и наибольшего) элементов `E first()` и `E last()`.

- для извлечения определенной части множества `SortedSet<E> subSet(E from, E to)`, `SortedSet<E> tailSet(E from)`, `SortedSet<E> headSet(E to)`.

- `Comparator<? super E> comparator()` возвращает объект *Comparator*, используемый для сортировки объектов множества
или *null*, если выполняется естественная сортировка.

*Пример создания TreeSet из готовой коллекции*

```java
public class DemoTreeSet {
    public static void main(String[] args) {

        ArrayList<String> col = new ArrayList<String>();
        boolean b;

        for (int i = 0; i < 6; i++)
            col.add((int) (Math.random() * 71) + "Y ");

        System.out.println(col + "- array list");

        TreeSet<String> set = new TreeSet<String>(col);

        System.out.println(set + "- tree set");

        b = set.add("5 Element"); // добавление (b = true)
        b = set.add("5 Element"); // добавление (b = false)

        // после добавления
        System.out.println(set + "- tree set после добавления");
        System.out.println(set.comparator()); // null т.к используется естественная сортировка класса String

        // извлечение наибольшего и наименьшего элементов
        System.out.println(set.last() + " " + set.first());

    }
}
```

*Результат может быть следующим*

```java
[44Y , 56Y , 49Y , 26Y , 49Y , 2Y ] - array list
[2Y , 26Y , 44Y , 49Y , 56Y ] - tree set
[2Y , 26Y , 44Y , 49Y , 5 Element, 56Y ] - tree set после добавления
null
56Y 2Y
```

*Объяснение примера*

*TreeSet* инициализируется списком и сортируется сразу же в процессе создания. После добавления нового элемента
производится неудачная попытка добавить его повторно. С помощью итератора элемент может быть найден и
удален из множества. Для множества, состоящего из обычных строк, используется по умолчанию правило обычной
лексикографической сортировки, поэтому метод `comparator()` возвращает *null*.

Если попытаться заменить тип *String* на *StringBuilder*, *StringBuffer* или любой пользовательский класс,
то создать множество *TreeSet* не удастся, т.к класс *String* уже реализует интерфейс *Comparable*.
Решением этого будет реализация интерфейса *Comparable<T>*.

Важно знать, что в отличии от *HashSet*, который проверяет уникальность добавляемых элементов по их хэш-коду,
*TreeSet* проверяет уникальность по компоратору, если метод `compare()` возвращает 0, то элементы считаются одинаковыми.

*Пример*

```java
TreeSet<Integer> numbers = new TreeSet<Integer>(new Comparator<Integer>() {
    @Override
    public int compare(Integer o1, Integer o2) {
        return 0;
    }
});

numbers.add(1);
numbers.add(2);
numbers.add(1);

System.out.println(numbers); // [1]
```

**LinkedHashSet**

`public class LinkedHashSet<E> extends HashSet<E> implements Set<E>, Cloneable, Serializable`

Класс *LinkedHashSet* расширяет класс *HashSet*, не добавляя никаких новых методов. *LinkedHashSet* работает на основе
*LinkedHashMap*.

*LinkedHashSet* отличается от *HashSet* тем, что хранит элементы в порядке их добавления.
Т.е, когда идет перебор объекта класса *LinkedHashSet* с применением итератора, элементы извлекаются в том порядке, в каком они были добавлены.
Эта коллекция лишь немного медленнее *HashSet*.

Две коллекции *Set* равны если они содержат одинаковые элементы. В случае с *LinkedHashSet* две коллекции равны,
если содержат одинаковые элементы, но расположение элементов может отличается, и метод `equals()` всё равно вернет *true*.

### 2.3 Queue Interface и реализации.

`public interface Queue<E> extends Collection<E> { ... }`

*Queue* - это коллекция, предназначенная для хранения элементов в порядке, нужном для их обработки.
Обычно, очередь не позволяет добавлять *null* элементы, однако в некоторых реализация интерфейса *Queue* есть возможность
добавление *null* элементов (например, *LinkedList*). Также не разрешается добавлять элементы, которые не можно сравнить с помощью класса *Comparator*.

![Java Collections Hierarchy](https://github.com/krasilnikovdmtr/java-interview/blob/master/images/Queue%20Interface%20-%20New%20Page.png?raw=true)

Обычно, очередь (но необязательно) строится по принципу *FIFO (First-In-First-Out)* - соответственно извлечение элемента
осуществляется с начала очереди, вставка элемента - в конец очереди.

Этот принцип нарушает, к примеру, приоритетная
очередь *(PriorityQueue)*, использующая переданный comparator при вставке нового элемента, либо расстановка элементов
осуществляется согласно естественному упорядочиванию *(natural ordering)*.

В дополнение к базовым операциям интерфейса *Collection*, очередь предоставляет дополнительные операции вставки, получения и контроля.

```java
E element();
boolean offer(E e);
E peek();
E poll();
E remove();
```

Методы инерфейса Queue существуют в двух формах:

- генерирующие исключения
- возвращающие значение *(null или false)*

<table>
    <thead>
        <tr>
            <th>Тип операции</th>
            <th>Генерирует исключение</th>
            <th>Возвращает специальное значение</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Добавление</td>
            <td>add(e)</td>
            <td>offer(e)</td>
        </tr>
        <tr>
            <td>Удаление</td>
            <td>remove()</td>
            <td>poll()</td>
        </tr>
        <tr>
            <td>Получение верхушки</td>
            <td>element()</td>
            <td>peek()</td>
        </tr>
    </tbody>
</table>

Метод `offer()` вставляет элемент в очередь, если это не удалось - возвращает *false*. Этот метод отличается от метода `add()`
интерфейса *Collection* тем, что метод `add()` может неудачно добавить элемент только с использованием *unchecked* исключения.

Методы `remove()` и `poll()` удаляют верхушку очереди и возвращают ее. Какой элемент будет удален (первый или последний)
зависит от реализации очереди. Методы `remove()` и `poll()` отличаются лишь поведением, когда очередь пустая:
метод `remove()` генерирует исключение, а метод `poll()` возвращает *null*.

Методы `element()` и `peek()` возвращают (но не удаляют) верхушку очереди.

**PriorityQueue**

`public class PriorityQueue<E> extends AbstractQueue<E> implements Serializable { ... }`

*PriorityQueue* единственная прямая реализация интерфейса *Queue* (не считая *LinkedList*, который больше является списком, чем очередью).
Эта очередь упорядочивает элементы либо по их натуральному порядку (используя интерфейс *Comparable*), либо с помощью
интерфейса *Comparator*, полученному в конструкторе.

### 3. Map Interface.

`java.util.Map<K, V>` так же как и `java.util.Collection<E>` является базовым интерфейсом фреймворка **Java Collections**.

![Java Collections Hierarchy](https://github.com/krasilnikovdmtr/java-interview/blob/master/images/Map%20Interface%20-%20New%20Page.png?raw=true)

Интерфейс `java.utils.Map` соотносит уникальные ключи со значениями. Ключ - это объект, который используется для последующего
извлечения данных.

Ключи должны быть уникальными, а значения могут дублироваться. При добавлении элемента по существующему ключу происходит
запись нового элемента по ключу вместо старого. Некоторые реализации *Map* допускают пустые ключи и пустые значения.

Интерфейс Map является типизированным.

`public interface Map<K,V> { ... }`

В интерфейсе `java.util.Map<K, V>` определены основные методы для манипуляции с данными, такие как получение значения
по ключу (`get()`), вставка (`put(), putAll()`), удаление (`remove(), clear()`), поиск (`containsKey()`, `containsValue()`) и т.д.

*Map* не поддерживают реализацию интерфейса *Iterable*, поэтому нельзя перебрать карту через цикл *for* в форме *for-each*.

Интерфейс Map предоставляет три способа для доступа к данным:

- `Set<K> keySet()` - возвращает множество ключей
- `Collection<V> values()` - возвращает коллекцию значений
- `Set<Map.Entry<K,V>> entrySet()` - возвращает множество объектов типа `Map.Entry<K,V>`

Интерфейс `Map.Entry` выглядит следующим образом:

```java
public static interface Map.Entry<K,V> {

    K getKey();
    V getValue();
    V setValue(V value);

}
```

Методы `getKey()` и `getValue()` позволяют получить ключ и значение пары. С помощью метода `setValue()` можно изменять
значения во время перебора элементов карты.

*Пример:*

```java
Map<String, String> map = new HashMap<String, String>();

map.put("1", "a");
map.put("2", "b");
map.put("3", "c");

for(Entry<String, String> entry : map.entrySet())
	if("2".equals(entry.getKey()))
		entry.setValue("x");

System.out.println(map);
```

*Результат выполнения:*

`{3=c, 2=x, 1=a}`

Существуют следующие реализации интерфейса Map:

- HashMap
- TreeMap
- LinkedHashMap
- WeakHashMap
- HashTable

Поведение и быстродействие *HashMap*, *TreeMap* и *LinkedHashMap* являются аналогами *HashSet*, *TreeSet* и *LinkedHashSet*.

**HashMap**

`public class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Cloneable, Serializable { ... }`

*HashMap* — реализация интерфейрса *Map*, основанная на хэш-таблице. Ключи и значения могут быть любых типов, в том числе и null.
Данная реализация не дает гарантий порядка элементов, а так же не гарантирует порядка элементов с течением времени (порядок элементов
меняется при увеличении размера *HashMap*).

*HashMap* имеет следующие конструкторы:

- `HashMap()` - создает пустой *HashMap* со значением *capacity 16* по умолчанию и *load factor 0.75*
- `HashMap(int initialCapacity)` - создает пустой *HashMap* по определенному значению  *initialCapacity* и *load factor 0.75*
- `HashMap(int initialCapacity, float loadFactor)` - создает пустой *HashMap* по определенному значению *initialCapacity* и *load factor*
- `HashMap(Map<? extends K,? extends V> m)` - создает пустой *HashMap* из готовой реализации *Map*

*Capacity* - это количество корзин *(buckets)* в хэш-таблице.

*Если заранее известно примерное количество элементов, которые будут добавлены в HashMap, то лучше его указывать в
качестве initialCapacity, т.к увеличение размера HashMap довольно ресурсоемкий процесс и работает не так как увеличение
массивов. При увеличении размера HashMap будет заново вычисляться хэш-код каждого элемента и определяться его положение в HashMap.*

**Как устроена HashMap**

*HashMap* работает по принципам хэширования. Для того, чтобы понять, как *HashMap* хранит в себе элементы, нужно
рассматривать *HashMap* как массив объектов. При выполнении `new HashMap()` создается массив элементов типа *Node<K,V>*
который в классе *HashMap* объявлен как *table*:
```java
/**
* Размер таблицы, изменяется при необходимости. Длина всегда должна быть
* кратна двум!
*/
transient Node<K,V>[] table;
```

По умолчанию будет создан пустой массив состоящий из 16 элементов, называемых корзинами *(buckets)*. Количество
корзинок можно изменить при помощи конструктора.

Каждый раз, при попытке добавить элемент в *HashMap* будет создаваться экземпляр класса *Node*, который будет добавлен
в массив *table* и который будет хранить данные добавляемого объекта.

**Node** - это вложенный статический класс в *HashMap* *(до Java 8 назывался Entry)*:

```java
static class Node<K,V> implements Map.Entry<K,V> {
    final int hash; // значение хэш-кода добавляемого элемента
    final K key; // ключ добавляемого элемента
    V value; // значение добавляемого элемента
    Node<K,V> next; // ссылка на следующий элемент в бакете, если такой есть

    //methods
}
```

![How hashmap works internally](https://github.com/krasilnikovdmtr/java-interview/blob/master/images/How%20hashmap%20works%20internally%20-%20New%20Page.png?raw=true)

Возникает вопрос, в какую ячейку массива *table* должен быть добавлен объект типа `Node<K, V>`.
Номер ячейки определяется на основании хэш-кода ключа, добавляемого элемента. Сначало высчитывается хэш-код ключа, затем
он делится на количество корзин и получаемый остаток от деления и является индексом массива, в который будет добавлен
элемент.

К примеру, если *hashCode == 122*, а в HashMap у нас 10 корзин, то *122 % 10* будет *2*, следовательно элемент будет
добавлен в массив под индексом 2. То же самое будет и для элементов с хэш-кодом 132 или 142 и т.д. В таком случаем
в одной корзине элементы будут хранится в виде linked list. *Новые элементы добавляются в начало linked list*.
В случае, если в HashMap добавляется элемент с ключом *null*, то элемент будет помещен в корзину с индексом 0, т.к
хэш-код от *null* будет равен 0 (*HashMap* может хранить только 1 элемент с ключом null).
В случае, если несколько объектов имеют одинаковый хэш-код *(коллизия)*,
то они так же будут добавлены под одним и тем же индексом и так же будут хранится в виде *linked list* (следует
заметить, что это не `java.util.LinkedList`, а наиболее упрощенная его реализация).

**В Java 8 принцип хранения элементов был немного изменен и при достижении определенного количества элементов в linked list,
он преобразовывается в сбалансированное дерево. Это связано с тем, чтобы улучшить наихудшую производительность
при O(n) на O(log(n))**

При достижении предельного количества элементов - *threshold*, размер хэш-таблицы увеличивается вдвое. Происходит
перехеширование ключей всех элементов и отсюда следует, что скорее всего некоторые элементы уже буду добавлены
в новые бакеты.

*Как HashMap гарантурет уникальность ключей?*

Что если мы поместим другой объект с другим значением но с тем же ключом, что был ранее?
Это должно привести к замене старого значения. Как это происходит? После определения позиции объекта *Node*,
во время прохода по *linked list*, вызывается `equals()` у ключа для каждого объекта *Node*.
Все эти *Node* объекты в *linked list* могут иметь аналогичные хеш-коды, но метод `equals()` проверит их на истинное сходство.
Это приведет к замене **только значения внутри объекта Node**, в противном случае новый *Node* будет добавлен в начало
*linked list*.

*В каком случае может быть потерян элемент в HashMap?*

В общем при попадании элемента в HashMap, высчитывается хеш код ключа, затем он делится на количество корзин,
получаем остаток отделения и это наша корзина. То есть если hashCode = 122, в HashMap у нас 10 корзин, то 122 % 10 = 2,
то есть наш элемент окажется в корзине с индексом 2.

После этого допустим хэш-код поменялся у ключа и стал 123. Теперь при поиске ключа мы будем искать в корзине с индексом 3,
а там элемента конечно нет. Если "повезло" и хеш код оказался, например, 152, то при итерировании внутри одной корзины
уже equals() вернет true и элемент будет найден, но это только усугубит проблему поиска проблемного места.

**Из этого следует вывод, что ключи должны быть в идеале immutable.**

**TreeMap**

`public class TreeMap<K,V> extends AbstractMap<K,V> implements NavigableMap<K,V>, Cloneable, Serializable { ... }`

*TreeMap* основан на *красно-черном дереве*, вследствие чего *TreeMap* сортирует элементы по ключу в естественном порядке
*(интерфейс Comparable)* или на основе заданного компаратора *(интерфейс Comparator)*. *TreeMap* гарантирует скорость
доступа *log(n)* для операций *containsKey, get, put и remove*.

Красно-черные деревья являются одной из форм сбалансированного бинарного поискового дерева.

*TreeMap* имеет следующие конструкторы:

- `TreeMap()` - создает пустой *TreeMap*, используя естественную сортировку по ключам
- `TreeMap(Comparator<? super K> comparator)` - создает пустой *TreeMap*, используя сортировку по ключам по заданному компоратору
- `TreeMap(Map<? extends K,? extends V> m)` - создает *TreeMap* на основе готового *Map m*, используя естественную сортировку ключей
- `TreeMap(SortedMap<K,? extends V> m)` - создает *TreeMap* на основе готового *SortedMap m*

*В отличии от HashMap TreeMap не позволяет использовать null в качестве ключа. При попытке добавить null будет
выброшен NullPointerException. Так же если при создании TreeMap в конструктор не был передан компаратор, то
нельзя использовать в качестве ключа кастомные объекты, которые не реализуют интерфейс Comparable, в противном случае
будет выброшен ClassCastException. В случае если объекты-ключи реализуют интерфейс Comparable и при создании TreeMap
был использован Comparator, то преимущество в сортировке будет у компаратора.*

**LinkedHashMap**

`public class LinkedHashMap<K,V> extends HashMap<K,V> implements Map<K,V> { ... }`

*LinkedHashMap* расширяет класс *HashMap* и отличается лишь тем, что хранит ключи в порядке их вставки в *Map* или в
порядке доступа к ним.
Важно знать, что при добавление элемента с существующим ключом, элемент будет заменен на новый, но порядок
останется первоначальным.

Эта реализаци *Map* лишь немного медленнее *HashMap*. Может содержать как *null-ключи*, так и *null-значения*.

*LinkedHashMap* имеет следующие конструкторы:

- `LinkedHashMap()` - создает пустое множество, с дефолтной емкостью *capacity* - 16 и *loadFactor* - 0.75
- `LinkedHashMap(int initialCapacity)` - создает множество с указанной начальной емкостью - *capacity* и дефолтным фактором загрузки - *loadFactor* - 0.75
- `LinkedHashMap(int initialCapacity, float loadFactor)` - создает множество с указанной начальной емкостью - *capacity* и фактором загрузки - *loadFactor*
- `LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)` - создает множество с указанной начальной емкостью - *capacity*,
    фактором загрузки - *loadFactoashr* и порядок по доступу
- `LinkedHashMap(Map<? extends K,? extends V> m)` - создает множество, в которое добавляются все элементы из *m*.

*accessOrder — указывает каким образом будет осуществляться доступ к элементам при использовании итератораЖ*

- *false* (по умолчанию) порядок согласно вставке в Map
- *true* - порядок согласно частоте доступа к элементам (от меньшего к большему)

На порядок по доступу влияют методы `get()` и `put()`.

*Пример*

```java
Map<Integer, String> numbers = new LinkedHashMap<Integer, String>();

numbers.put(5, "a");
numbers.put(4, "b");
numbers.put(3, "c");
numbers.put(2, "d");
numbers.put(1, "e");

System.out.println(numbers); // {5=a, 4=b, 3=c, 2=d, 1=e}

Map<Integer, String> numbersWithAccessOrder = new LinkedHashMap<Integer, String>(5, 1, true);

numbersWithAccessOrder.put(5, "a");
numbersWithAccessOrder.put(4, "b");
numbersWithAccessOrder.put(3, "c");
numbersWithAccessOrder.put(2, "d");
numbersWithAccessOrder.put(1, "e");

numbersWithAccessOrder.get(3);
numbersWithAccessOrder.get(1);
numbersWithAccessOrder.get(5);

System.out.println(numbersWithAccessOrder); // {4=b, 2=d, 3=c, 1=e, 5=a}
```

Как видно, в первом случае элементы выводятся в порядке, в котором они были добавлены в LinkedHashMap. Во вотором
случае элементы выводятся сначала по порядку добавления в *LinkedHashMap*, а потом в порядке доступа к ним.

**Эти два способа сортировки элементов и используются в LinkedHashMap**.

- insertion order
- access order

**Как устроена LinkedHashMap**

*LinkedHashMap* использует такую же схему для хранения данных как и *HashMap*, только элементы хранятся в виде *двусвязного списка*.

*LinkedHashMap* имеет внутренний класс *Entry*, который используется для хранения элементов в *LinkedHashMap*.

```java
static class Entry<K,V> extends HashMap.Node<K,V> {
    Entry<K,V> before, after;
    Entry(int hash, K key, V value, Node<K,V> next) {
     super(hash, key, value, next);
    }
}
```

Как видно, класс *Entry* наследует все свойства класса *Node* из *HashMap* и добавляет два своих поля `before` и `after`, тем самым
определяя работу *LinkedHashMap*, как *двусвязного списка*. `before` и `after` хранят ссылки на предыдущий и следующий элемент.

**WeakHashMap**

`public class WeakHashMap<K,V> extends AbstractMap<K,V> implements Map<K,V> { ... }`

*WeakHashMap* - это структура данных, основанная на использовании *WeakReference* для хранения **ключей**.
Таким образом, пара "ключ-значение" будет удалена из *WeakHashMap*, если на объект-ключ более не имеется сильных ссылок.

**HashTable**

`public class Hashtable<K,V> extends Dictionary<K,V> implements Map<K,V>, Cloneable, java.io.Serializable { ... }`

*Hashtable* так же как и *HashMap* основан на хеш-таблице и используют хеширование для определения расположения элементов.

Главными отличиями *Hashtable* от *HashMap* являются:

- *Hashtable* синхронизирован, *HashMap* несинхронизирован. Следовательно, производительность *HashMap* выше,
чем у *Hastable*. В однопоточных средах нужно использовать *HashMap*, в многопоточных можно использовать *Hashtable*,
но лучше использовать *ConcurrentHashMap* (высокая производительность, больше возможностей).

- в *Hashtable* нельзя использовать *null* ни в качестве ключа, ни в качестве значения.
В *HashMap* можно один раз использовать *null* в качестве ключа и сколько угодно в качестве значения.

Для хранения элементов *HashTable* использует вложенный статический класс *Entry<K,V>*

`private static class Entry<K,V> implements Map.Entry<K,V> { ... }`

Работа с элементами в *HashTable* происходит точно так же, как и в *HashMap*. Только по умолчанию количество бакетов - capacity
равно 11, а не 16.

### 4. Итератор.

Итератор — это объект, который позволяет итерироваться по элементам коллекции. Все коллекции реализуют разные структуры для
хранения данных. Где-то возможен обход коллекции по индексу, а где-то индекса вообще нет.

К примеру, в реализациях интерфейса *List* - *ArrayList* и *LinkedList* есть возможность получить элемент по индексу, используя
метод `get()`. Следовательно, можно обойти все элементы коллекции, используя цикл *for loop*. Но, к примеру, с элементами
реализаций интерфейса *Set* так поступить уже нельзя.

Для решения этой проблемы используется *объект итератор*. Объект-итератор позволяет поочередно получить каждый элемент
коллекции в порядке, зависящем от конкретной реализации.
Все коллекции в `java.util`, которые реализуют интерфейс *Collection* должны реализовывать метод, который должен
возвращать объект итератор, т.к интерфейс *Collection* наследуется от интерфейса *Iterable*, в котором есть всего один метод:

`public abstrace Iterator<T> iterator();`

*Пример использования интератора с Set*:

```java
Set set = new HashSet();
set.add("One");
set.add("Two");
set.add("Three");

Iterator iterator = set.iterator();

while (iterator.hasNext()) {
    System.out.println(iterator.next());
}
```

Интерфейс *Iterator<E>*, описывающий, как должен выглядеть итератор выглядит следующим образом:

```java
public interface Iterator<E> {

    boolean hasNext();
    E next();
    default void remove() {
            throw new UnsupportedOperationException("remove");
        }

}
```

- `hasNext()` — метод возвращает true, если в коллекции ещё остались элементы и false, если достигнут конец коллекции
- `next()` — возвращает следующий элемент коллекции, при этом итератор переходит на следующий элемент
- `remove()` — удаляет элемент

Метод `next()` выбрасывает исключение, если больше нет элементов, поэтому перед вызовом метода `next()` надо выполнять проверку
методом `hasNext()`. При вызове метода `remove()` будет удален последний элемент, который итератор вернул при помощи
метода `next()`.

*Как использовать итератор с интерфейсом Map?*

Интерфейс *Map* не наследует интерфейс *Iterable* и в нем нет метода `iterator()`, но есть такие методы как:

- `Set<Map.Entry<K,V>> entrySet()`
- `Set<K> keySet()`
- `Collection<V> values()`

А эти методы уже возвращают объекты типа *Set* и *Collection*, следовательно, могут быть итерируемы.

*Пример*

```java
Map<Integer, String> users = new HashMap();

users.put(1, "user1");
users.put(2, "user2");
users.put(3, "user3");

Set<Map.Entry<Integer, String>> set = users.entrySet();
Iterator<Map.Entry<Integer, String>> iterator = set.iterator();

while(iterator.hasNext()) {

    Map.Entry<Integer, String> user = iterator.next();
    System.out.println(user.getKey() + " is " + user.getValue());

}
```

**Так же итератор используется для безопасного удаления элементов из коллекций в цикле**

К примеру, что будет если удалять элементы из коллекции *List* в простом цикле:

```java
ArrayList<String> list = new ArrayList<String>(Arrays.asList("a", "b", "c", "d"));

for (int i = 0; i < list.size(); i++) {
    list.remove(i);
}

System.out.println(list); // [b, d]
```

Ошибка получается в результате того, что когда элемент удаляется, размер *List* уменьшается, т.к все элементы сдвигаются
левее и индексы меняются.

Так же неправильно использовать цикл вида *for-each*, даже не смотря на то, что он использует *iterator*.

```java
ArrayList<String> list = new ArrayList<String>(Arrays.asList("a", "b", "c", "d"));

for (String s : list) {
        if (s.equals("a"))
                list.remove(s);
}
```

В результате будет `Exception in thread "main" java.util.ConcurrentModificationException`.

Правильным решением для удаления элементов в цикле является использования итератора.

```java
ArrayList<String> list = new ArrayList<String>(Arrays.asList("a", "b", "c", "d"));
Iterator<String> iter = list.iterator();
while (iter.hasNext()) {
        String s = iter.next();

        if (s.equals("a")) {
                iter.remove();
        }
}
```

Важно знать, что метод `next()` должен быть вызван до метода `remove()`.
В цикле в стиле *for-each* компилятор вызовет метод `remove()`, а уже потом `next()`, что вызовет ошибку *ConcurrentModificationException*.

**Интерфейс ListIterator**

Интерфейс *Iterator* предоставляет ограниченный функционал и предоставляет возможность получить элементы коллекции
только в одном направлении. Больший набор методов предоставляет другой итератор - интерфейс *ListIterator*.
*Iterator* используется реализациями интерфейсов *List* и *Set*.
*ListIterator* используется только классами, реализующими интерфейс *List*, - *LinkedList*, *ArrayList* и др.

`public interface ListIterator<E> extends Iterator<E> { ... }`

Интерфейс *ListIterator* расширяет интерфейс *Iterator* и определяет ряд дополнительных методов:

- `void add(E obj)` - добавляет объект *obj* перед элементом, который должен быть возвращен следующим вызовом *next()*
- `boolean hasPrevious()` возвращает *true*, если в коллекции имеется предыдущий элемент
- `E next()` - возвращает следующий элемент, если такого нет, то генерируется исключение *NoSuchElementException*
- `E previous()` - возвращает предыдущий элемент, если такого нет, то генерируется исключение *NoSuchElementException*
- `int nextIndex()` - возвращает индекс следующего элемента. Если такого нет, то возвращается размер списка
- `int previousIndex()` - возвращает индекс предыдущего элемента. Если такого нет, то возвращается число -1
- `void remove()` - удаляет текущий элемент из списка. Таким образом, этот метод должен быть вызван после методов
    `next()` или `previous()`, иначе будет сгенерировано исключение *IllegalStateException*
- `void set(E obj)` - присваивает текущему элементу, выбранному вызовом методов `next()` или `previous()`, ссылку на объект *obj*

Важно знать, что *ListIterator* не хранит текущий элемент при итерации. В отличии от этого он указывает на положение между
двумя элементами. Между элементом, который будет возвращен при вызове метода `E previous()` и элементом `E next()`

![How ListIterator works](https://github.com/krasilnikovdmtr/java-interview/blob/master/images/How%20ListIterator%20works%20-%20New%20Page.png?raw=true)

*^* - указывает на положение иетартора

*Пример использования ListIterator*

```java
ArrayList<String> states = new ArrayList<String>();
states.add("Germany");
states.add("France");
states.add("Italy");
states.add("Spain");

ListIterator<String> listIterator = states.listIterator();

while(listIterator.hasNext()){
    System.out.print(listIterator.next() + " "); // Germany France Italy Spain
}
// сейчас текущий элемент - Spain
// изменим значение этого элемента
listIterator.set("Portugal");

// пройдемся по элементам в обратном порядке
while(listIterator.hasPrevious()){
    System.out.print(listIterator.previous() + " "); // Portugal Italy France Germany
}
```